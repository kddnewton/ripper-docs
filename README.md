# Ripper

Ripper is a Ruby standard library that acts as an event-based Ruby script parser. It can be used to gather information about Ruby scripts without running them. It can also generate [syntax trees](https://en.wikipedia.org/wiki/Abstract_syntax_tree) from source code.

Ripper is generated from Ruby's own parsing code, and is distributed with Ruby. That means the Ripper syntax is completely up-to-date with its corresponding Ruby.

When Ruby parses source code, it first [scans](https://en.wikipedia.org/wiki/Lexical_analysis) the source code into tokens. Each token sends a scanner event as it is recognized. The scanner events are then grouped into parser events. Each event will create a node in the syntax tree. For instance, an assignment node ([assign](#assign)) for `a=7` would come from scanner nodes for `a` ([ident](#ident)), `=` ([op](#op)) and `7` ([int](#int)). A parser event can group parser events, scanner events or both.

Ruby's parser generator, in `parse.y`, contains [comments for Ripper to use](https://github.com/ruby/ruby/blob/master/parse.y#L1519). When Ripper is compiled, it modifies Ruby's compiler code in `parse.y` based on these comments to make its own compiler code, very similar to Ruby's.

Ripper allows you to define handlers for scanner and parser events, which can let you analyze Ruby programs, or recognize control structures (e.g. an assignment inside an "if" statement, which is often an error.) If you can write out the syntax tree to Ruby code (e.g. using the outdated [sorcerer gem](https://github.com/jimweirich/sorcerer) or equivalent), then you could modify syntax trees and write out the resulting code.

## Usage

If you'd like to see the syntax tree that Ripper generates for Ruby code, you can try Ripper in `irb`. The `::sexp_raw` method shows the syntax tree that is constructed from the scanner and parser events, while `::lex` shows the scanner events. You can also use the `::sexp` method to group events in a more readable way:

```ruby
$ irb
irb(main):001:0> require "ripper"
=> false
irb(main):002:0> pp Ripper.sexp_raw("a=7")
[:program,
 [:stmts_add,
  [:stmts_new],
  [:assign, [:var_field, [:@ident, "a", [1, 0]]], [:@int, "7", [1, 2]]]]]
irb(main):003:0> pp Ripper.lex("a=7")
[[[1, 0], :on_ident, "a", CMDARG],
 [[1, 1], :on_op, "=", BEG],
 [[1, 2], :on_int, "7", END]]
irb(main):004:0> pp Ripper.sexp("a=7")
[:program,
 [[:assign, [:var_field, [:@ident, "a", [1, 0]]], [:@int, "7", [1, 2]]]]]
```

Scanner events tend to include the location where the token starts as an array of two integers, such as `[1,2]` above. The first number is a 1-indexed line number (in this case line 1) and a 0-indexed character number within the line (for `[1,2]`, 2 means the third character of that line.)

## Ripper Events

To use Ripper properly, you'll want to know the different parser and scanner events. You can use `irb` to find out what events are generated by specific Ruby code. Below is a reference to the different scanner and parser events.

Each event specifies:

* Whether it is a "parser" event or a "scanner" event. Things like identifiers, constants, operators, and the like are scanner events, while higher-level nodes like assignment, conditionals, and loops are parser events.
* An example of the syntax that would trigger the event.
* How you would write a handler method for this event, and the types of objects that would be passed in as arguments to that handler.

## Patterns

There are patterns in the various Ripper events that make it slightly easier to work with.

### Lists

Often your Ruby code will contain a variable-length list of items, like parameters to a method call, or items in an array, or statements inside a block. Ripper doesn't use variable-length events. Instead, every event has a fixed number of items.

In order to keep the number of parameters fixed for each event, Ripper often creates an empty item and then adds to it. For instance, here is how array literals are parsed by Ripper:

```ruby
2.7.1 :004 > pp Ripper.sexp_raw("[1, 2, 3, 4, 5]")
[:program,
 [:stmts_add,
  [:stmts_new],
  [:array,
   [:args_add,
    [:args_add,
     [:args_add,
      [:args_add,
       [:args_add, [:args_new], [:@int, "1", [1, 1]]],
       [:@int, "2", [1, 4]]],
      [:@int, "3", [1, 7]]],
     [:@int, "4", [1, 10]]],
    [:@int, "5", [1, 13]]]]]]
```

Notice that `[:args_new]` has no additional parameters, and the other array elements are added one at a time using `args_add`.

One of the differences between `::sexp` and `::sexp_raw` is that it replaces \_new/\_add chains with a Ruby array, such as stmts_new/stmts_add being replaced here:

```ruby
2.7.1 :005 > pp Ripper.sexp("[1, 2, 3, 4, 5]")
[:program,
 [[:array,
   [[:@int, "1", [1, 1]],
    [:@int, "2", [1, 4]],
    [:@int, "3", [1, 7]],
    [:@int, "4", [1, 10]],
    [:@int, "5", [1, 13]]]]]]
```

The [args_new](#args_new)/[args_add](#args_add) events are used for a list of method call parameters. But they aren't the only similar set of events. Events used in similar ways include:

* [args_new](#args_new)/[args_add](#args_add)/[args_add_block](#args_add_block)/[args_add_star](#args_add_star)/[args_forward](#args_forward) - argument lists
* [mlhs_new](#mlhs_new)/[mlhs_add](#mlhs_add) - left-hand side of a multiple assignment list
* [mrhs_new](#mrhs_new)/[mrhs_add](#mrhs_add) - right-hand side of a multiple assignment list
* [qsymbols_new](#qsymbols_new)/[qsymbols_add](#qsymbols_add) - `%i` array literal parts
* [qwords_new](#qwords_new)/[qwords_add](#qwords_add) - `%w` array literal parts
* [regexp_new](#regexp_new)/[regexp_add](#regexp_add) - regular expression literal parts
* [stmts_new](#stmts_new)/[stmts_add](#stmts_add) - statement lists
* [string_content](#string_content)/[string_add](#string_add) - string literal parts
* [symbols_new](#symbols_new)/[symbols_add](#symbols_add) - `%I` array literal parts
* [word_new](#word_new)/[word_add](#word_add) - word parts within a `%W` array literal
* [words_new](#words_new)/[words_add](#words_add) - `%W` array literal parts
* [xstring_new](#xstring_new)/[xstring_add](#xstring_add) - `%x` command string literal parts

Other events, such as [qsymbols_new](#qsymbols_new)/[qsymbols_add](#qsymbols_add) work very much like [args_new](#args_new)/[args_add](#args_add), and this \_new/\_add naming convention is common. Here's what qsymbols new/add looks like in `::sexp_raw`:

```ruby
2.7.1 :006 > pp Ripper.sexp_raw("%i[one two three]")
[:program,
 [:stmts_add,
  [:stmts_new],
  [:array,
   [:qsymbols_add,
    [:qsymbols_add,
     [:qsymbols_add, [:qsymbols_new], [:@tstring_content, "one", [1, 3]]],
     [:@tstring_content, "two", [1, 7]]],
    [:@tstring_content, "three", [1, 11]]]]]]
```

When using Ripper by inheriting from the Ripper parent class, this is often handled by the `*_new` methods creating an array and the `*_add` methods appending to that array. You can see this pattern used in `Ripper::SexpBuilderPP`, which generates the `sexp` return values, [here](https://github.com/ruby/ruby/blob/38d255d023373a665ce0d2622ed6e25462653a2a/ext/ripper/lib/ripper/sexp.rb#L178-L184).

### Statements

Certain nodes function as wrappers around lists of statements (`stmts_add`/`stmts_new` nodes). For instance, an `if` or `else` block normally contains a list of statements, or the inside of a `while` loop, `rescue` clause or `proc`. Fortunately, they are all handled in the same way for each node type, which makes them simpler to work with if you're going to be iterating through statement lists (for instance in a formatter or a static analyzer). The nodes that wrap statements are:

* [BEGIN](#BEGIN) - the only argument
* [END](#END) - the only argument
* [bodystmt](#bodystmt) - the first argument
* [brace_block](#brace_block) - the second argument after the optional block variables
* [else](#else) - the only argument
* [elsif](#elsif) - the second argument, after the predicate
* [ensure](#ensure) - the only argument
* [for](#for) - the third argument, after the block variable and the collection
* [if](#if) - the second argument, after the predicate
* [in](#in) - the second argument, after the left-hand side
* [lambda](#lambda) - the second argument if you're using a brace block (if you're using a do block it's a [bodystmt](#bodystmt) node because you can attach rescue handlers)
* [program](#program) - the only argument (this is the top-level list of statements)
* [rescue](#rescue) - the second argument, after the rescued error
* [string_embexpr](#string_embexpr) - the first argument representing the interpolated statements
* [unless](#unless) - the second argument, after the predicate
* [until](#until) - the second argument, after the predicate
* [when](#when) - the second argument, after the case declaration
* [while](#while) - the second argument, after the predicate

### Naming

Certain nodes are named similarly which can indicate similar functionality.

A couple of common prefixes you will find in the list of events include:

* `assoc*` - having to do with the contents of a hash. This includes [assoc_new](#assoc_new) (a key/value pair in a hash), [assoc_splat](#assoc_splat) (a splatted expression in a hash), and [assoclist_from_args](#assoclist_from_args) (the node that wraps a list of the `assoc_*` nodes inside a hash).
* `def*` - having to do with defining methods. This includes [def](#def) (a regular method definition), [defs](#defs) (a singleton-class method definition).
* `m*` - mostly nodes that relate to mass assignment. This includes [massign](#massign) (the overall parent node), [mlhs](#mlhs) (the left-hand side (LHS) of a mass assignment), [mlhs_add_post](#mlhs_add_post) (LHS of a mass assignment nodes that are after a splat), [mlhs_add_star](#mlhs_add_star) (LHS of a mass assign nodes that are splatted), [mlhs_paren](#mlhs_paren) (parentheses used in the LHS of a mass assign node, usually for destructuring), [mrhs](#mrhs) (the right-hand side (RHS) of a mass assignment), [mrhs_add_star](#mrhs_add_star) (RHS of a mass assignment that is being splatted), and [mrhs_new_from_args](#mrhs_new_from_args) (creating an [mrhs](#mrhs) node from a list of arguments, as in a list of rescued exceptions).

While a couple of common suffixes you will find in the list of events include:

* `*field` - anything that can be assigned to. This includes [aref_field](#aref_field) (assigning using `#[]=`), [const_path_field](#const_path_field) (assigning to a nested constant), [field](#field) (assigning to a value on an expression), [top_const_field](#top_const_field) (assigning to a top-level constant), and [var_field](#var_field) (a regular identifier being used in an assignment).
* `*_mod` - the modifier form of some keyword. This includes [if_mod](#if_mod), [rescue_mod](#rescue_mod), [unless_mod](#unless_mod), [until_mod](#until_mod), and [while_mod](#while_mod). Each of the prefixes of those event names tells you which keyword is being used.
* `*ptn` - patterns used in pattern matching. This includes [aryptn](#aryptn) (array patterns), [fndptn](#fndptn) (find patterns), and [hshptn](#hshptn) (hash patterns).

### Location

For a lot of tools that interact with a syntax tree, you will need information about where every node comes from in the source code. For that, `Ripper` provides two methods: `lineno` and `column`. These methods have a lot of nuance, however, so it's important to know what they're actually referring to.

#### `lineno`

`lineno` refers to line number that is stored in the internal parser state as it is parsing. It has different behavior depending on if you're handling a scanner event or a parser event. Note that line-numbers are 1-indexed (the first line in the file is line 1, not 0).

If you're handling a scanner event, the `lineno` is always going to be the line number at the start of the token that triggered that scanner event. For example if you have an [ident](#ident) scanner event `variable`, then the value will be whatever line the `v` is on.

If you're handling a parser event, then `lineno` will be the line number that the parser is looking at when the production rule that you're referencing is reduced. Note that this is not necessarily the line number of the final token in the rule.

#### `column`

`column` refers to the byte offset that is stored in the internal parser state as it is parsing an individual line. Similar to how it works for `lineno`, it has different behavior depending on the kind of event you're handling.

If you're handling a scanner event, then `column` will always be the byte offset in the line that the token appears on _before_ the token itself. So for example, if you're parsing `1 + 2`, then in the [int](#int) scanner event handler for the `2` in that statement, `column` will have a value of `4`.

If you're handling a parser event, the `column` will be the byte offset that the parser is looking at when the production rule that you're referencing is reduced. This can be especially confusing when you factor in comments. Let's say you're parsing `1 + 2 # 3`. Both of the [int](#int) scanner events will have the expected column values (`0` and `4`), whereas the [binary](#binary) node that represents that addition will have a `column` value of `9` (because that is the point at which the parser reduced the [binary](#binary)).

It's important here to note the difference between offset and byte offset. If you're parsing a string of source like `party = "ðŸŽ‰"`, the overall [assign](#assign) node that represents this assignment will have a `column` value of `14` (5 for the variable, 3 for the spaces and operator, 2 for quotes, and 4 bytes to represent the emoji). Note that this is also encoding-specific, as different encodings will represents codepoints with differing numbers of bytes.

For these reasons, it's easiest to rely on location information from the scanner events for determining the bounds of parser events. For example, if you're handling a [while](#while) event, you can look for the `while` and `end` keywords to know the bounds of your node.

## Events

Ripper works in an evented style internally. To use it that way, you'll usually want to inherit from the Ripper parent class, define some methods and parse your code. Here's a very simple example using the [heredoc_beg](#heredoc_beg) scanner event:

```ruby
require "ripper"

class HeredocFinder < ::Ripper
  def on_heredoc_beg(start_line)
    if start_line.start_with?("<<") && !start_line.start_with?("<<~")
      puts "Warning: use only indenting heredocs! Problem in #{filename} at location #{lineno}:#{column}"
    end
  end
end

HeredocFinder.new(DATA, __FILE__, DATA.lineno + 1).parse
__END__
puts <<EXAMPLE
  This is a multiline
  heredoc in Ruby
EXAMPLE
```

Parser events can be handed in the same way. Remember that if you return different values from handlers (like `on_args_new`/`on_args_add`), this may change the values other handlers receive (like `on_method_add_arg`.)

The Ruby parser can be complicated, and can generate a variety of nodes and structures. You should probably check the source code you care about using Ripper.sexp_raw and Ripper.lex to see what events occur for that source code. Ripper::PARSER_EVENT_TABLE contains a mapping of all events to their arity (number of arguments.) The parser table can be useful when detecting many or all events at once, or when forwarding all unrecognised events to a different piece of code.

Here is a more complicated event-based parser example:

```ruby
require "ripper"

class CallArgListPrinter < ::Ripper
  def initialize(*args, **kw)
    @all_calls = []
    super
  end

  def on_method_add_arg(called, call_item)
    @all_calls.push [called, call_item]
    [called, call_item]
  end

  # If you don't return a value for args_new/args_add, you won't get argument data for on_method_add_arg.
  def on_args_new()
    { line: lineno, col: column, args: [] }
  end

  def on_args_add(call_item, arg)
    call_item[:args].push arg
    call_item
  end

  def print_out
    @all_calls.each do |val|
      puts "Call: #{val.inspect}"
    end
  end
end

parser = CallArgListPrinter.new(DATA, __FILE__, DATA.lineno + 1)
parser.parse
parser.print_out
__END__

a(1, 2, 3)

c.call(4, 5, 6)

# Not detected because it uses call instead of fcall and method_add_arg
"ruby".reverse

# Detected but generates a significantly different AST, which confuses our simple logic
"ruby".split("u")
```

### `BEGIN`

`BEGIN` is a parser event that represents the use of the `BEGIN` keyword, which hooks into the lifecycle of the interpreter. Whatever is inside the block will get executed when the program starts. The syntax looks like the following:

```ruby
BEGIN {
}
```

Interestingly, BEGIN doesn't allow the `do...end` keywords for the block. Only braces are permitted.

The handler for this event accepts one parameter that is always a `stmts` node:

```ruby
def on_BEGIN(stmts); end
```

### `CHAR`

`CHAR` is a parser event that represents a single codepoint in the script encoding. For example:

```ruby
?a
```

is a representation of the string literal `"a"`. You can use control characters with this as well, as in `?\C-a`. The handler for this event accepts one parameter that is always a string:

```ruby
def on_CHAR(value); end
```

### `END`

`END` is a parser event that represents the use of the `END` keyword, which hooks into the lifecycle of the interpreter. Whatever is inside the block will get executed when the program ends. The syntax looks like the following:

```ruby
END {
}
```

Interestingly, you can't use the `do...end` keywords for the block. The handler for this event accepts one parameter that is always a `stmts` node:

```ruby
def on_END(stmts); end
```

### `__end__`

`__end__` is a scanner event that represents `__END__` syntax, which allows individual scripts to keep content after the main ruby code that can be read through the DATA constant. It looks like:

```ruby
puts DATA.read

__END__
some other content that is not executed by the program
```

The handler for this event accepts one parameter that is always a string containing `"__END__\n"` (provided you're using `\n` as the newline). Notably it does not contain the content appearing after the keyword, so you need to use the line number information to access that.

```ruby
def on___end__(value); end
```

### `alias`

`alias` is a parser event that represents the use of the `alias` keyword with regular arguments (not global variables). The `alias` keyword is used to make a method respond to another name as well as the current one. For example, to get the method `name` to also respond to `aliased_name`, you would:

```ruby
alias aliased_name name
```

Now, in the current context you can call `aliased_name` and it will execute the `name` method. When you're aliasing two methods, you can either provide bare words (like the example above) or you can provide symbols (note that this includes dynamic symbols like `:"left-#{middle}-right"`).

The handler for this event accepts two parameters, that correspond to the first and second arguments to the keyword. So, for the above example the left would be the symbol literal `aliased_name` and the right could be the symbol literal `name`. Either argument can be a [dyna_symbol](#dyna_symbol) node or a [symbol_literal](#symbol_literal) node.

```ruby
def on_alias(left, right); end
```

### `aref`

`aref` is a parser event when you're pulling a value out of a collection at a specific index. Put another way, it's any time you're calling the method `#[]`. As an example:

```ruby
collection[index]
```

The nodes usually contains two children, the collection and the index. In some cases, you don't necessarily have the second child node, because you can call procs with a pretty esoteric syntax. In the following example, you wouldn't have a second child node:

```ruby
collection[]
```

Because the left-hand side of this expression can be any primary Ruby expression, its type is not known. The right-hand side (if provided) will be either an [args_add](#args_add) node or an [args_add_block](#args_add_block) node.

```ruby
def on_aref(collection, index); end
```

### `aref_field`

`aref_field` nodes are for assigning values into collections at specific indices. Put another way, it's any time you're calling the method `#[]=`. The `aref_field` node itself is just the left side of the assignment, and they're always wrapped in [assign](#assign) nodes. As an example:

```ruby
collection[index] = value
```

The nodes always contain two children, the expression that corresponds to the collection being indexed and the index itself. The collection is any primary Ruby expression. The index can optionally be omitted (in the very rare case that someone defines a `#[]=` method that accepts no arguments).

```ruby
def on_aref_field(collection, index); end
```

### `arg_ambiguous`

`arg_ambiguous` is a parser event that represents when the parser sees an argument as ambiguous. For example, in the following snippet:

```ruby
value //
```

the question becomes if the forward slash is being used as a division operation or if it's the start of a regular expression.

Unlike most other parser events, the output of the handler method for this event is not passed up to any parent nodes, as it is not a node in the resulting tree. As such, it does not matter what value is returned from the handler method. The handler accepts one parameter that is a string representing the ambiguous argument. In the above example, it would be `"/"`.

```ruby
def on_arg_ambiguous(value); end
```

### `arg_paren`

`arg_paren` is a parser event that represents wrapping arguments to a method inside a set of parentheses. For example, in the follow snippet:

```ruby
method(argument)
```

there would be an `arg_paren` node around the [args_add_block](#args_add_block) node that represents the set of arguments being sent to the `method` method. The argument child node can be `nil` if no arguments were passed, as in:

```ruby
method()
```

The handler for this event accepts one parameter, which is either an [args_add](#args_add), [args_add_block](#args_add_block), or [args_forward](#args_forward) node. It can also optionally be `nil`.

```ruby
def on_arg_paren(args); end
```

### `args_add`

`args_add` is a parser event that represents a single argument inside a list of arguments to any method call or an array. It accepts as arguments the previous `args_add` or [args_new](#args_new) node as well as a value which can be anything that could be passed as an argument.

For example, in the following snippet:

```ruby
method(first, second, third)
```

you would first receive an event for [args_new](#args_new). Then for each subsequent argument, you would receive an event for `args_add`, with the following arguments:

* The result of [args_new](#args_new) and the [vcall](#vcall) node for `first`
* The result of the first `args_add` call and the [vcall](#vcall) node for `second`
* The result of the second `args_add` call and the [vcall](#vcall) node for `third`

Note that because of the nature of the chaining here, it's not possible to know if you're on the last argument to a list without further inspecting the source through the scanner events.

```ruby
def on_args_add(args, arg); end
```

### `args_add_block`

`args_add_block` is a parser event that represents a list of arguments and potentially a block argument. If no block is passed, then the second argument will be the literal `false`. `args_add_block` is commonly seen being passed to any method where you use parentheses (wrapped in an [arg_paren](#arg_paren) node). It's also used to pass arguments to the various control-flow keywords like `return`.

For example, in the following snippet, the `&block` would trigger the `args_add_block` to have a [vcall](#vcall) node as its second argument:

```ruby
method(argument, &block)
```

whereas in the following snippet, you would have an `args_add_block` node with `false` as the block:

```ruby
method(argument)
```

The handler for this event accepts the arguments (as an [args_new](#args_new), [args_add](#args_add), or [args_add_star](#args_add_star) node) and the optional block (which is usually a [vcall](#vcall) node, or `false` if it's not passed).

```ruby
def on_args_add_block(args, block); end
```

### `args_add_star`

`args_add_star` is a parser event that represents adding a splat of values to a list of arguments. For example, in the following snippet, the `*arguments` would trigger an `args_add_star` event:

```ruby
method(prefix, *arguments, suffix)
```

This event is very similar to the [args_add](#args_add) event except that whatever expression is being used as an argument is prefixed with the splat operator. The handlers for this event accepts two arguments: the parent arguments node as well as the expression that is being splatted.

```ruby
def on_args_add_star(args, arg); end
```

### `args_forward`

`args_forward` is a parser event that represents forwarding all kinds of arguments onto another method call. For example, in the following snippet:

```ruby
def request(method, path, **headers, &block); end

def get(...)
  request(:GET, ...)
end

def post(...)
  request(:POST, ...)
end
```

both the `get` and `post` methods are forwarding all of their arguments (positional, keyword, and block) on to the `request` method. The `args_forward` node appears in both the caller (the `request` method calls) and the callee (the `get` and `post` definitions).

The handler for this event accepts no arguments. It is passed up to the parent argument node (be it an [args_add](#args_add) or [args_add_block](#args_add_block) node).

```ruby
def on_args_forward; end
```

### `args_new`

`args_new` is a parser event that represents the beginning of a list of arguments to any method call or an array. It can be followed by any number of [args_add](#args_add), [args_add_block](#args_add_block), or [args_forward](#args_forward) events, which end up in a chain. For example, in the following snippet:

```ruby
method(argument)
```

there will be one [args_add](#args_add) node that contains as its first child an `args_new` node and its second child a [vcall](#vcall) node for the argument. The handlers for this event accepts no arguments. It is passed up to the parent argument node (be it an [args_add](#args_add) or [args_add_block](#args_add_block) node).

```ruby
def on_args_new; end
```

### `array`

`array` is a parser event that contains myriad child nodes because of the special array literal syntax like `%w` and `%i`. For example, the following lines all produce an `array` event:

```ruby
[]
[one, two, three]
[*one_two_three]
%w[one two three]
%i[one two three]
%W[one two three]
%I[one two three]
```

In order, the child node types coming in would be `nil`, [args](#args), [args_add_star](#args_add_star), [qwords](#qwords), [qsymbols](#qsymbols), [words](#words), and [symbols](#symbols). The handler for this event should account for those various types.

```ruby
def on_array(contents); end
```

### `aryptn`

`aryptn` is a parser event that represents matching against an array pattern using the Ruby `2.7`+ pattern matching syntax. It's one of the more complicated events, because the four parameters that it accepts can almost all be `nil`. First, let's look at what kind of code triggers this event:

```ruby
case [1, 2, 3]
in [Integer, Integer]
  "matched"
in Container[Integer, Integer]
  "matched"
in [Integer, *, Integer]
  "matched"
end
```

An `aryptn` event triggers with four parameters: an optional constant wrapper, an array of positional matches, an optional splat with identifier, and an optional array of positional matches that occur after the splat. All of the `in` clauses above would trigger an `aryptn` event.

In the first clause, the first parameter would be `nil` because it's not being wrapped with a constant. The second parameter would be an array of nodes representing the two positional matches. The third parameter would be `nil` because there's no splat operator, and the fourth parameter would be `nil` for the same reason.

In the second clause, the first parameter would be a [const](#const) node containing the `Container` name, and the rest of the parameters would be the same as in the first clause.

The final clause would have a `nil` constant, a single-element array containing the first `Integer` match for the second parameter, a [var_field](#var_field) node containing the splat for the third parameter, and another single-element array containing the final `Integer` match for the fourth parameter.

```ruby
def on_aryptn(const, preargs, splatarg, postargs); end
```

### `assign`

`assign` is a parser event that represents assigning something to a variable or constant. Generally, the left side of the assignment is going to be any node that ends with the name `field` (see [naming](#naming)).

```ruby
variable = value
```

It accepts as arguments the left side of the expression before the equals sign and the right side of the expression. The right side of the expression can be any of most of the nodes in the tree.

```ruby
def on_assign(left, right); end
```

### `assoc_new`

`assoc_new` is a parser event that contains a key-value pair within a hash. It is a child event of either an [assoclist_from_args](#assoclist_from_args) or a [bare_assoc_hash](#bare_assoc_hash).

```ruby
{ key1: value1, key2: value2 }
```

In the above example, the would be two `assoc_new` nodes. Each would contain a key ([label](#label) nodes) and a value ([vcall](#vcall) nodes).

```ruby
def on_assoc_new(key, value); end
```

### `assoc_splat`

`assoc_splat` is a parser event that represents double-splatting a value into a hash (either a hash literal or a bare hash in a method call).

```ruby
{ **pairs }
```

Much like `assoc_new`, these nodes get added into an array that gets sent up to either an [assoclist_from_args](#assoclist_from_args) or a [bare_assoc_hash](#bare_assoc_hash). The handler for this event receives a single parameter the represents the value being double-splatted (which can be any Ruby expression).

```ruby
def on_assoc_splat(contents); end
```

### `assoclist_from_args`

`assoclist_from_args` is a parser event that represents the key-value pairs of a hash literal. Its parent node is always a hash.

```ruby
{ key1: value1, key2: value2 }
```

The handler for this event accepts a single parameter: an array containing either [assoc_new](#assoc_new) or [assoc_splat](#assoc_splat) nodes.

```ruby
def on_assoclist_from_args(assocs); end
```

### `backref`

`backref` is a scanner event that represents a global variable referencing a matched value. It comes in the form of a $ followed by a positive integer.

```ruby
$1
```

The handler accepts a single string parameter containing the value as seen in the source.

```ruby
def on_backref(value); end
```

### `backtick`

`backtick` is a scanner event that represents the use of the \` operator. It's usually found being used for an [xstring_literal](#xstring_literal), but could also be found as the name of a method being defined.

```ruby
`ls`
```

The above example would trigger two `backtick` events. The handler accepts a single string parameter that always contains a single backtick.

```ruby
def on_backtick(value); end
```

### `bare_assoc_hash`

`bare_assoc_hash` is a parser event that represents a hash of contents being passed as a method argument (and therefore has omitted braces). It's very similar to an [assoclist_from_args](#assoclist_from_args) event.

```ruby
method(key1: value1, key2: value2)
```

In the above example, the event would be triggered for the source bound between the `key1` [label](#label) and the `value2` [vcall](#vcall). The handler for this event accepts a single array parameter of assoc events (either [assoc_new](#assoc_new) or [assoc_splat](#assoc_splat)).

```ruby
def on_bare_assoc_hash(assocs); end
```

### `begin`

`begin` is a parser event that represents the beginning of a `begin`..`end` chain.

```ruby
begin
  value
end
```

The handler for this event accepts a single [bodystmt](#bodystmt) event that has all of the potential clauses (`rescue`/`else`/`ensure`).

```ruby
def on_begin(bodystmt); end
```

### `binary`

`binary` is a parser event that represents any expression that involves two sub-expressions with an operator in between. This can be something that looks like a mathematical operation:

```ruby
1 + 1
```

but can also be something like pushing a value onto an array:

```ruby
array << value
```

The handler for this event accepts three parameters. The first and last represent the left- and right-hand side of the operation. The second parameter represents the operator being used. On most Ruby implementations, the operator is a symbol (like `:+` or `:<<` for the examples above). However, on JRuby, it's an [op](#op) node which matches some other event handlers.

```ruby
def on_binary(left, operator, right); end
```

### `block_var`

`block_var` is a parser event that represents the parameters being declared for a block. Effectively this event is everything contained within the pipes. This includes all of the various parameter types, as well as block-local variable declarations. For example:

```ruby
method do |positional, optional = value, keyword:, &block|
end
```

In the above example, all of those parameters would be included inside the child [params](#params) node. You can use a relatively esoteric syntax for declaring block-local variables, as in:

```ruby
method do |positional; local|
end
```

With this syntax, `local` becomes a variable local only to the block, and can shadow an outer variable without overwriting or modifying it. The handler for this event accepts two parameters. The first is the [params](#params) node that contains all of the declared parameters. The second is an optional array of [ident](#ident) nodes that represent any declared block-local variables. If none are present, then the second parameter will be the literal `false`.

```ruby
def on_block_var(params, locals); end
```

### `blockarg`

`blockarg` is a parser event that represents declaring a block parameter on a method definition.

```ruby
def method(&block); end
```

In the above example, the `&block` would trigger a `blockarg` event. The handler for this event always accepts a single [ident](#ident) parameter which represents the name of the block parameter.

```ruby
def on_blockarg(ident); end
```

### `bodystmt`

`bodystmt` is a parser event that represents all of the possible combinations of clauses within the body of a method or do block. This means the regular statements and the optionally attached `rescue`, `else`, and `ensure` blocks. It can be passed up to any node that accepts these kinds of bodies like method definitions, lambdas using the `do` keyword, class and module definitions, singleton class scopes, and [begin](#begin) nodes. For example:

```ruby
class Container
rescue
end

class << self
rescue
end

lambda do
rescue
end
```

In all three of the above snippets, the `rescue` keyword is used to indicate that a `bodystmt` node is being passed up to the various parent nodes. The handler for this event accepts four parameters. The first is a [stmts_add](#stmts_add) node representing the first (and only required) set of statements. The second is an optional [rescue](#rescue) node. The third is an optional second set of statements that belong in the `else` clause if one is given. The fourth and final parameter is an optional [ensure](#ensure) node.

```ruby
def on_bodystmt(stmts, rescued, ensured, elsed); end
```

Note that it's difficult to determine the character bounds of this node since it doesn't necessarily know where it started. You can look at the first child node that you encounter, but that might be missing comments that conceptually "belong" to this node. To remedy this, if you need the chracter bounds you need to determine them in each of the parent event handlers.

### `brace_block`

`brace_block` is a parser event that represents passing a block to a method call using the `{` `}` operators. For example:

```ruby
method { variable + 1 }
method { |variable| variable + 1 }
```

The handler for this event accepts as arguments an optional [block_var](#block_var) event that represents any parameters to the block as well as a [stmts_add](#stmts_add) event that represents the statements inside the block. So in the first line of the example above the first parameter would be `nil`, but in the second line it would be present.

```ruby
def on_brace_block(block_var, stmts); end
```

### `break`

`break` is a parser event that represents using the `break` keyword. For example:

```ruby
break
break 1
```

The handler for this event accepts one parameter that is an [args_new](#args_new) event (in the case of no parameters, as in the first line of the example) or an [args_add_block](#args_add_block) event (in the case parameters were passed, as in the second line of the example) that contains all of the arguments being passed to the `break` keyword.

```ruby
def on_break(args); end
```

### `call`

`call` is a parser event representing a method call. This event doesn't contain the arguments being passed (if arguments _are_ passed, this node will get nested under a [method_add_arg](#method_add_arg) node).

```ruby
receiver.message
```

There is one esoteric syntax that comes into play here as well. If the last parameter to the handler for this event is the symbol literal `:call`, then it represents calling a callable object in a very odd looking way, as in:

```ruby
callable.(1, 2, 3)
```

The handler for this event accepts as parameters the receiver of the message (which can be another nested `call` as well), the operator being used to send the message (this can be an [op](#op) node containing `.` or `&.`, or the symbol literal `:"::"`), and the message that is being sent to the receiver. The message will usually be an [ident](#ident) node, but can also be a [backtick](#backtick), [op](#op), or [const](#const) node, depending on the look of the message. It can also be the already mentioned `:call` symbol literal.

```ruby
def on_call(receiver, operator, message); end
```

### `case`

`case` is a parser event that represents the beginning of a `case` chain. For example:

```ruby
case value
when 1
  "one"
when 2
  "two"
else
  "number"
end
```

`case` will also get dispatched when using the `in` keyword on a single line, as in:

```ruby
value in pattern
```

Finally, `case` will get dispatched when using right-hand assignment in Ruby 2.7+, as in:

```ruby
expression => value
```

The handler for this event accepts two parameters: the optional value that is being used as the predicate for the `case` chain, and the consequent clause (a [when](#when) or [in](#in) clause).

```ruby
def on_case(switch, consequent); end
```

### `class`

`class` is a parser event that represents defining a class using the `class` keyword. For example:

```ruby
class Container
end
```

Classes can have path names as their class name in case it's being nested under a namespace, as in:

```ruby
class Namespace::Container
end
```

Classes can also be defined as a top-level path, in the case that it's already in a namespace but you want to define it at the top-level instead, as in:

```ruby
module OtherNamespace
  class ::Namespace::Container
  end
end
```

All of these declarations can also have an optional superclass reference, as in:

```ruby
class Child < Parent
end
```

That superclass can actually be any Ruby expression, it doesn't necessarily need to be a constant, as in:

```ruby
class Child < method
end
```

The handler for this event accepts as parameters the name of the class (a [const_path_ref](#const_path_ref), [const_ref](#const_ref), or [top_const_ref](#top_const_ref) node), the optional value of the superclass (any Ruby expression), and the [bodystmt](#bodystmt) event that represents the statements evaluated within the context of the class.

```ruby
def on_class(const, superclass, bodystmt); end
```

### `comma`

`comma` is a scanner event that represents the use of the `,` operator. In general you don't necessarily need to handle this event, but it's useful for determining if the source is using trailing commas in literals or method calls.

```ruby
method(
  parameter1,
  parameter2,
)
```

The above example would trigger two `comma` events. The handler accepts a single string parameter that always contains a single comma.

```ruby
def on_comma(value); end
```

### `command`

`command` is a parser event representing a method call with arguments and no parentheses. Note that `command` events only happen when there is no explicit receiver for this method, as in the following example:

```ruby
method argument
```

The handler for this event accepts as arguments the name of the method (either a [const](#const) or an [ident](#ident) node) and the arguments being passed to the method (as an [args_add_block](#args_add_block) node).

```ruby
def on_command(message, args); end
```

### `command_call`

`command_call` is a parser event representing a method call on an object with arguments and no parentheses.

```ruby
object.method argument
```

The handler for this event accepts as arguments the receiver of the method (any Ruby expression), the operator being used to send the method (this can be an [op](#op) node containing `.` or `&.`, or the symbol literal `:"::"`), the name of the method (an [op](#op), [ident](#ident), or [const](#const) node, depending on what the method name looks like), and the arguments being passed to the method (an [args_add_block](#args_add_block) node).

```ruby
def on_command_call(receiver, operator, method, args); end
```

### `comment`

`comment` is a scanner event that represents a comment in source.

```ruby
# comment
```

The above example would trigger one `comment` events. The handler for this event accepts a single string parameter that contains the value of the comment (including the `#` sign).

```ruby
def on_comment(value); end
```

Note that this is one of a few scanner events that give you a string value that can potentially extend beyond the range of ASCII. If there's a magic encoding comment at the top of the source that ripper is parsing (as in `# encoding: Shift_JIS`) then the encoding of the string being passed into the handler for this event will match it. If you're planning on serializing the resulting syntax tree in any way, it's important to handle the encoding change in this event handler.

### `const`

`const` is a scanner event that represents a literal value that _looks like_ a constant. This could actually be a reference to a constant:

```ruby
Const
```

It could also be something that looks like a constant in another context, as in a method call to a capitalized method:

```ruby
object.Const
```

or a symbol that starts with a capital letter:

```ruby
:Const
```

The handler for this event accepts a single string parameter that contains the value of the const.

```ruby
def on_const(value); end
```

### `const_path_field`

`const_path_field` is a parser event that always represents the child node of some kind of assignment. It represents when you're assigning to a constant that is being referenced as a child of another variable. For example:

```ruby
object::Const = value
```

The handler for this event accepts two parameters. The first is the value to the left of the `::` operator. It's the parent object of the constant that is being assigned. It can be any Ruby expression. The second is the [const](#const) node that represents the constant being assigned (as in `Const` in the example above).

```ruby
def on_const_path_field(left, const); end
```

### `const_path_ref`

`const_path_ref` is a parser event that is a very similar to [const_path_field](#const_path_field) except that it is not involved in an assignment. It looks like the following example:

```ruby
object::Const
```

The handler for this event is the same as [const_path_field](#const_path_field). The first parameter for the left side of the `::` operator and the second parameter for the right.

```ruby
def on_const_path_ref(left, const); end
```

### `const_ref`

`const_ref` is a parser event that represents the name of the constant being used in a class or module declaration. In the following example it is the [const](#const) scanner event that has the contents of `Container`.

```ruby
class Container; end
```

The handler for this event always accepts a single [const](#const) parameter.

```ruby
def on_const_ref(const); end
```

### `cvar`

`cvar` is a scanner event that represents the use of a class variable.

```ruby
@@variable
```

The handler for this event accepts a single string parameter that contains the name of the variable including the `@@` prefix.
 
 ```ruby
def on_cvar(value); end
```

### `def`

`def` is a parser event that represents defining a regular method on the current self object. It accepts as arguments an [ident](#ident) node (the name of the method being defined), a [params](#params) node (the parameter declaration for the method), and a [bodystmt](#bodystmt) node which represents the statements inside the method. As an example, here are the parts that go into this:

```ruby
def method(param) do result end
```

In this case `method` would be the [ident](#ident), `param` would be inside the [params](#params) node, and [bodystmt](#bodystmt) would contain the single `result` statement.

You can also have single-line methods since Ruby 3.0+, which have slightly different syntax but still flow through this event handler. Those look like:

```ruby
def method = result
```

In this case `method` would be the [ident](#ident), the [params](#params) node would be `nil` since this single-line method doesn't declare any parameters, and the final parameter would just be a [vcall](#vcall) for the `result` method.

The handler for this event accepts the [ident](#ident) and optional [params](#params) nodes (note that this will be a [paren](#paren) node containing the [params](#params) node if parentheses are used in the declaration). It also accepts the statements, which can either be a [bodystmt](#bodystmt) node in the case of a multi-line method declaration or any Ruby expression in the case of a single-line statement.

```ruby
def on_def(ident, params, body); end
```

### `defined`

`defined` is a parser event that represents the use of the rather unique `defined?` operator. It can be used with and without parentheses.

```ruby
defined?(variable)
```

The handler for this event accepts a single parameter that represents whatever Ruby expression is being passed to the operator.

```ruby
def on_defined(value); end
```

### `defs`

`defs` is a parser event that represents defining a singleton method on an object. For example:

```ruby
def object.method(param) do result end
```

It accepts the same arguments as the [def](#def) event, as well as the target and operator on which this method is being defined. So in the example above, the parameters would be the [vcall](#vcall) for `object` as the target, a [period](#period) node for the `operator`, and then the same parameters as the [def](#def) event above.

```ruby
def on_defs(target, operator, ident, params, body); end
```

### `do_block`

`do_block` is a parser event that represents passing a block to a method call using the `do` and `end` keywords.

```ruby
method do |value|
end
```

The handler for this event accepts as arguments an optional [block_var](#block_var) event that represents any parameters to the block as well as a [bodystmt](#bodystmt) event that represents the statements inside the block.

```ruby
def on_do_block(block_var, bodystmt); end
```

### `dot2`

`dot2` is a parser event that represents using the `..` operator between two expressions. Usually this is to create a range object.

```ruby
1..2
```

Sometimes this operator is used to create a flip-flop.

```ruby
if value == 5 .. value == 10
end
```

The handler for this event accepts two parameters representing the left and right side of the `..` operator. Note that either one of them could be `nil`, but not both.

```ruby
def on_dot2(left, right); end
```

### `dot3`

`dot3` is a parser event that represents using the `...` operator between two expressions. It's effectively the same event as the [dot2](#dot2) event but with this operator you're asking Ruby to omit the final value.

```ruby
1...2
```

Like [dot2](#dot2) it can also be used to create a flip-flop.

```ruby
if value == 5 ... value == 10
end
```

The handler for this event accepts two parameters representing the left and right side of the `...` operator. Note that either one of them could be `nil`, but not both.

```ruby
def on_dot3(left, right); end
```

### `dyna_symbol`

`dyna_symbol` is a parser event that represents a symbol literal that uses quotes to interpolate its value. For example, if you had a variable `variable` and you wanted a symbol that contained its value, you would write:

```ruby
:"#{variable}"
```

They can also be used as a special kind of dynamic hash key, as in:

```ruby
{ "#{key}": value }
```

The handler for this event accepts one parameter which is either a [string_content](#string_content) node (representing an empty string, as in `:""`) or a [string_add](#string_add) node (representing a non-empty string, as in the first example).

```ruby
def on_dyna_symbol(contents); end
```

### `else`

`else` is a parser event that represents the end of a `if` or `unless` chain.

```ruby
if variable
else
end
```

The handler for this event accepts a single [stmts_add](#stmts_add) node that represents the list of statements inside the `else` clause.

```ruby
def on_else(stmts_add); end
```

### `elsif`

`elsif` is a parser event that represents another clause in an `if` or `unless` chain.

```ruby
if variable
elsif other_variable
end
```

The handler for this event accepts the predicate to the `elsif` operator (any Ruby expression), the statements inside the clause (a [stmts_add](#stmts_add) node) and an optional consequent clause (`elsif` or [else](#else)).

```ruby
def on_elsif(predicate, stmts_add, consequent); end
```

### `embdoc`

`embdoc` is a scanner event that gets dispatched when the parser is inside a multi-line comment and receive a new line of content. For example, in the following multi-line comment, the `embdoc` event would be dispatched twice:

```ruby
=begin
first line
second line
=end
```

The handler for this event accepts a single string parameter containing the value of the line of content. Note that this includes the trailing newline.

```ruby
def on_embdoc(value); end
```

### `embdoc_beg`

`embdoc_beg` is a scanner event that represents the beginning of a multi-line comment.

```ruby
=begin
comment
=end
```

In the above example, it represents the `=begin` string. The handler for this event accepts a single string parameter that always contains `"=begin\n"` (provided you're using `\n` newlines).

```ruby
def on_embdoc_beg(value); end
```

### `embdoc_end`

`embdoc_end` is a scanner event that represents the ending of a multi-line comment.

```ruby
=begin
comment
=end
```

In the above example, it represents the `=end` string. The handler for this event accepts a single string parameter that always contains `"=end\n"` (provided you're using `\n` newlines).

```ruby
def on_embdoc_end(value); end
```

### `embexpr_beg`

`embexpr_beg` is a scanner event that represents the beginning token for using interpolation inside of a parent node that accepts string content (like a string or regular expression).

```ruby
"Hello, #{person}!"
```

The handler for this event accepts a single string parameter that always contains the string literal `"#{"`.

```ruby
def on_embexpr_beg(value); end
```

### `embexpr_end`

`embexpr_end` is a scanner event that represents the ending token for using interpolation inside of a parent node that accepts string content (like a string or regular expression).

```ruby
"Hello, #{person}!"
```

The handler for this event accepts a single string parameter that always contains the string literal `"}"`.

```ruby
def on_embexpr_end(value); end
```

### `embvar`

`embvar` is a scanner event that represents the use of shorthand interpolation for an instance, class, or global variable into a parent node that accepts string content (like a string or regular expression).

```ruby
"#@variable"
```

In the example above, the `#` would be triggering the `embvar` event because it forces `@variable` to be interpolated. The handler for this event accepts a single string parameter that is always the string literal `"#"`.

```ruby
def on_embvar(value); end
```

Note that changing the return value of this method does not impact other event handlers since the result never gets passed up the tree.

### `ensure`

`ensure` is a parser event that represents the use of the `ensure` keyword and its subsequent statements.

```ruby
begin
ensure
end
```

The handler for this event accepts a single [stmts_add](#stmts_add) event that represents the statements inside the `ensure` clause.

```ruby
def on_ensure(stmts_add); end
```

### `excessed_comma`

`excessed_comma` is a parser event that represents a trailing comma in a list of block parameters. It changes the block parameters such that they will destructure.

```ruby
[[1, 2, 3], [2, 3, 4]].each do |first, second,|
end
```

In the above example, an `excessed_comma` node would appear in the third position of the [params](#params) node that is used to declare that block. The third position typically represents a `rest`-type parameter, but in this case is used to indicate that a trailing comma was used. The handler for this event accepts no parameters (though in previous versions of Ruby it accepted a string literal with a value of `","`).

```ruby
def on_excessed_comma; end
```

### `fcall`

`fcall` is a parser event that represents the piece of a method call that comes before any arguments (i.e., just the name of the method). It is used in places where the parser is sure that it _is_ a method call and not potentially a local variable.

```ruby
method(argument)
```

In the above example, it's referring to the `method` segment. The handler for this event accepts a single [ident](#ident) or [const](#const) parameter that represents the name of the message being sent.

```ruby
def on_fcall(message); end
```

### `field`

`field` is a parser event that is always the child of an assignment. It represents assigning to a "field" on an object, as in:

```ruby
object.variable = value
```

The handler for this event accepts three parameters. The first is everything to the left of the operator (the object owning the field, can be any Ruby expression), the second is the operator itself (a [period](#period) for `.`, an [op](#op) for `&.`, or the symbol literal `:"::"` for `::`), and the third is everything to the right of the operator (the name of the field being assigned, either a [const](#const) or [ident](#ident) node).

```ruby
def on_field(left, operator, right); end
```

### `float`

`float` is a scanner event that represents a floating point value literal.

```ruby
1.0
```

The handler for this event accepts a single string parameter that represents the float's value in string form.

```ruby
def on_float(value); end
```

### `fndptn`

`fndptn` is a parser event that represents matching against a pattern where you find a pattern in an array using the Ruby 3.0+ pattern matching syntax.

```ruby
case value
in [*, 7, *]
end
```

In the above example, the syntax means it will match an array that contains a `7` integer literal.

The handler for this event accepts four parameters. The first is an optional constant wrapper like [aryptn](#aryptn). The second is a [var_field](#var_field) that represents the first `*` operator and its optional name. The third is any array of Ruby expressions that represent all of the values in the array between the two `*` operators. The fourth and final parameter is another [var_field](#var_field) that represents the second `*` operator and its optional name.

```ruby
def on_fndptn(const, presplat, values, postsplat); end
```

### `for`

`for` is a parser event that represents using a for loop.

```ruby
for value in list do
end
```

The handler for this event accepts three parameters. The first represents the list of iteration parameters. It can be an [mlhs](#mlhs), an [mlhs_add_star](#mlhs_add_star), or a [var_field](#var_field) node, depending on the kind of iteration. The second is the Ruby expression that represents the value being iterated. The third and final parameter is a [stmts_add](#stmts_add) node that represents the list of statements inside the for loop.

```ruby
def on_for(iterator, enumerable, stmts_add); end
```

### `gvar`

`gvar` is a scanner event that represents a global variable literal.

```ruby
$variable
```

The handler for this event accepts a single string value that represents the variable including the `$` prefix.

```ruby
def on_gvar(value); end
```

### `hash`

`hash` is a parser event that represents a hash literal.

```ruby
{ key => value }
```

The handler for this event accepts a single optional [assoclist_from_args](#assoclist_from_args) parameter that represents the contents of the hash literal. If the hash literal is empty, this parameter will be `nil`.

```ruby
def on_hash(assoclist_from_args); end
```

### `heredoc_beg`

`heredoc_beg` is a scanner event that represents the beginning of the heredoc.

```ruby
<<~DOC
  contents
DOC
```

In the above example, a `heredoc_beg` would get dispatched containing the `"<<~DOC"` string literal. The handler for this event accepts a single string parameter that represents the beginning declaration of the heredoc.

```ruby
def on_heredoc_beg(value); end
```

### `heredoc_dedent`

`heredoc_dedent` is a parser event that occurs when you're using a heredoc with a tilde (otherwise known as a "squiggly" heredoc).

```ruby
<<~DOC
  contents
DOC
```

This event will get dispatched once when the `heredoc` is closed. The handler for this event accepts two parameters. The first is the content of the heredoc, represented with a [string_add](#string_add) node. The second is an integer that represents the number of characters that should be stripped off from the beginning of each line of the heredoc (because of the semantics of the tilde in the declaration).

```ruby
def on_heredoc_dedent(string_add, width); end
```

### `heredoc_end`

`heredoc_end` is a scanner event that represents the end of the heredoc literal.

```ruby
<<~DOC
  contents
DOC
```

The handler for this event accepts a single string parameter that represents the end of the heredoc declaration. In the above example it would be the string literal `"DOC\n"` (provided you're using `\n` newlines).

```ruby
def on_heredoc_end(value); end
```

### `hshptn`

`hshptn` is a parser event that represents matching against a hash pattern using the Ruby 2.7+ pattern matching syntax.

```ruby
case value
in { key: }
end
```

The handler for this event accepts three parameters. The first is an optional constant wrapper, like [aryptn](#aryptn) and [fndptn](#fndptn). The second is an array of pairs of [label](#label) and an optional Ruby expression node for the value. Those pairs represent the key-value pairs used in the pattern matching. In the example above, it would contain a single pair of the `key` label and `nil` for the value. The third and final parameter is a [var_field](#var_field) that represents the optional double splat for grabbing the remaining keys.

```ruby
def on_hshptn(const, pairs, kwrest); end
```

### `ident`

`ident` is a scanner event that represents an identifier anywhere in code. It can represent a very large number of things, depending on where it is in the syntax tree.

```ruby
value
```

The handler for this event accepts a single string parameter representing the value in the source.

```ruby
def on_ident(value); end
```

### `if`

`if` is a parser event that represents the first clause in an `if` chain.

```ruby
if predicate
end
```

The handler for this event accepts three parameters. The first is any Ruby expression that represents the predicate used in the `if` clause. The second is a [stmts_add](#stmts_add) node that represent the statements inside the clause. The third and final parameter is an optional consequent clause the follows the `if` which can be an [elsif](#elsif) or [else](#else) clause.

```ruby
def on_if(predicate, stmts_add, consequent); end
```

### `ifop`

`ifop` is a parser event that represents a ternary clause.

```ruby
predicate ? truthy : falsy
```

The handler for this event accepts three parameters. The first is the predicate used in the ternary. The second is the value used in the truthy case. The third is the value used in the falsy case. All three parameters can be any Ruby expression.

```ruby
def on_ifop(predicate, truthy, falsy); end
```

### `if_mod`

`if_mod` is a parser event that represents the modifier form of an `if` statement.

```ruby
value if predicate
```

The handler for this event accepts two parameters. The first is the predicate for the `if` clause. The second is the statement being executed if the predicate is truthy. Both of the parameters can be any Ruby expression.

```ruby
def on_if_mod(predicate, statement); end
```

### `ignored_nl`

`ignored_nl` is a scanner event that represents a newline in the middle of a statement where it should be ignored. For example:

```ruby
object.first
      .second
```

The `ignored_nl` event will get triggered on the newline between the first and second method calls. The handler for this event accepts a single parameter that is always `nil`.

```ruby
def on_ignored_nl(value); end
```

### `ignored_sp`

`ignored_sp` is a scanner event that represents the space before the content of each line of a squiggly heredoc that will be removed from the string before it gets transformed into a string literal. For example:

```ruby
<<~DOC
  line1
    line2
DOC
```

In the above snippet, two `ignored_sp` event would be dispatched. The first would be dispatched with two spaces and the second with four.

```ruby
def on_ignored_sp(value); end
```

### `imaginary`

`imaginary` is a scanner event that represents an imaginary number literal.

```ruby
1i
```

The handler for this event accepts a single string parameter that represents the value as seen in the source.

```ruby
def on_imaginary(value); end
```

### `in`

`in` is a parser event that represents using the `in` keyword within the Ruby 2.7+ pattern matching syntax.

```ruby
case value
in pattern
end
```

Alternatively, in Ruby 3+ it is also used to handle rightward assignment for pattern matching.

```ruby
value in pattern
```

Or, if you're using rightward assignment without pattern matching:

```ruby
expression => value
```

The handler for this event accepts three parameters. The first is the pattern that is being matched, which can be any Ruby expression. The second is a [stmts_add](#stmts_add) node that represents the statements inside the `in` clause. The final is an optional consequent clause that follows this `in` clause, which can be either an `in` or [else](#else).

Note that for a single-line rightward pattern matching like the second example or single-line rightward assignment like the third example, both the second and third parameters to this event handler will be `nil`.

```ruby
def on_in(pattern, stmts_add, consequent); end
```

### `int`

`int` is a scanner event the represents a number literal.

```ruby
1
```

The handler for this event accepts a single string parameter that represents the value as seen in the source.

```ruby
def on_int(value); end
```

### `ivar`

`ivar` is a scanner event the represents an instance variable literal.

```ruby
@variable
```

The handler for this event accepts a single string parameter that represents the value as seen in the source, including the `@` prefix.

```ruby
def on_ivar(value); end
```

### `kw`

`kw` is a scanner event the represents the use of a keyword. It can be almost anywhere in the syntax tree, so you end up seeing it quite a lot.

```ruby
if value
end
```

In the above example, `kw` would be dispatched twice: once for the `if` and once for the `end`. Note that anything that matches the list of keywords in Ruby will dispatch this event, so if you use a keyword in a symbol literal for instance:

```ruby
:if
```

then the contents of the [symbol](#symbol) node will contain a `kw` node. The handler for this event accepts a single string parameter that represents the value as seen in the source.

```ruby
def on_kw(value); end
```

### `kwrest_param`

`kwrest_param` is a parser event that represents defining a parameter in a method definition that accepts all remaining keyword parameters.

```ruby
def method(**kwargs); end
```

The handler for this event accepts a single optional [ident](#ident) node that represents the name of the parameter.

```ruby
def on_kwrest_param(ident); end
```

### `label`

`label` is a scanner event that represents the use of an identifier to associate with an object. You can find it in a hash key, as in:

```ruby
{ key: value }
```

In this case `"key:"` would be the body of the label. You can also find it in pattern matching, as in:

```ruby
case value
in key:
end
```

In this case `"key:"` would be the body of the label.

The handler for this event accepts a single string parameter that represents the value as seen in the source, including the `:` suffix.

```ruby
def on_label(value); end
```

### `label_end`

`label_end` is a scanner event that represents the end of a dynamic symbol. If for example you had the following hash:

```ruby
{ "key": value }
```

then the string `"\":"` would be the value of this `label_end`. The handler for this event accepts a single string parameter that represents the value as seen in the source. It's particularly useful for determining the type of quote being used by the label.

```ruby
def on_label_end(value); end
```

### `lambda`

`lambda` is a parser event that represents using a lambda literal (_not_ the `lambda` method call).

```ruby
->(value) { value * 2 }
```

The handler for this event accepts parameters a [params](#params) node (which can be a [paren](#paren) node if parentheses are used) that represents any parameters to the lambda and a statements node ([stmts_add](#stmts_add) for a lambda using braces and [bodystmt](#bodystmt) for a lambda using the `do` and `end` keywords) that represents the statements inside the lambda.

```ruby
def on_lambda(params, stmts); end
```

### `lbrace`

`lbrace` is a scanner event representing the use of a left brace, i.e., `{`.

The handler for this event accepts a single string parameter that is always `"{"`.

```ruby
def on_lbrace(value); end
```

### `lbracket`

`lbracket` is a scanner event representing the use of a left bracket, i.e., `[`.

The handler for this event accepts a single string parameter that is always `"["`.

```ruby
def on_lbracket(value); end
```

### `lparen`

`lparen` is a scanner event representing the use of a left parenthesis, i.e., `(`.

The handler for this event accepts a single string parameter that is always `"("`.

```ruby
def on_lparen(value); end
```

### `magic_comment`

`magic_comment` is a scanner event that represents the use of a pragma at the beginning of the file. Usually it will include something like
`frozen_string_literal` (the key) with a value of `true` (the value). It can also take multiple other forms though if using the `-*-` emacs-style file pragmas. Note that it's not just known values that dispatch this event, anything that matches a specific pattern will as well.

```ruby
# frozen_string_literal: true
```

The handler for this event accepts two parameters, the key and value. They both come in as string literals.

```ruby
def on_magic_comment(key, value); end
```

Note that the return value of this method will be passed immediately up into the [comment](#comment) event handler. So it is possible to skip this handler definition entirely and just process it in the comments handler.

### `massign`

`massign` is a parser event that is a parent node of any kind of multiple assignment. This includes splitting out variables on the left like:

```ruby
first, second, third = value
```

as well as splitting out variables on the right, as in:

```ruby
value = first, second, third
```

Both sides support splats, as well as variables following them. There's also destructuring behavior that you can achieve with the following:

```ruby
first, = value
```

In this case a would receive only the first value of the `value` enumerable. The handler for this event accepts two parameters representing the left and right side of the `=` operator. The left-hand side will be any of [mlhs](#mlhs), [mlhs_add_post](#mlhs_add_post), [mlhs_add_star](#mlhs_add_star), or [mlhs_paren](#mlhs_paren) depending on how it is declared. The right-hand side will be any Ruby expression.

```ruby
def on_massign(left, right); end
```

### `method_add_arg`

`method_add_arg` is a parser event that represents a method call with arguments and parentheses.

```ruby
method(argument)
```

The handler for this event accepts two parameters. The first represents the method being called, the second represents the arguments being passed to the method. In the example above, those would be [fcall](#fcall) and [arg_paren](#arg_paren) nodes, respectively.

You can also dispatch a `method_add_arg` event with a method on an object, as in:

```ruby
object.method(argument)
```

In this case the first parameter would be a [call](#call) node. Finally, you can dispatch a `method_add_arg` event when you are calling a method with no receiver that ends in a `?`. In this case, the parser knows it's a method call and not a local variable, so it dispatches a `method_add_arg` event as opposed to a [vcall](#vcall) event, as in:

```ruby
method?
```

In that case, the second parameter would be an [args_new](#args_new) event.

```ruby
def on_method_add_arg(method, args); end
```

### `method_add_block`

`method_add_block` is a parser event that represents a method call with a block argument.

```ruby
method {}
```

The handler for this event accepts two parameters, the method being called and the block being passed. The first can be a lot of different kinds of nodes, depending on how the method is being called. That parameter can be:

* [fcall](#fcall) if there is no explicit receiver (`method {}`)
* [call](#call) if there is an explicit receiver (`object.method {}`)
* [method_add_arg](#method_add_arg) if there are arguments in parentheses (`method(value) {}`)
* [command](#command) if there is no explicit receiver, it's a [do_block](#do_block) for the block, and there are arguments (`method value do end`)
* [command_call](#command_call) if there is an explicit receiver, it's a [do_block](#do_block) for the block, and there are arguments (`object.method value do end`)

The second parameter will always be a [brace_block](#brace_block) or a [do_block](#do_block) node.

```ruby
def on_method_add_block(method, block); end
```

### `mlhs_add`

`mlhs_add` is a parser event that represents adding another variable onto a list of variables within a multiple assignment.

```ruby
first, second, third = value
```

In the above example, three `mlhs_add` events would be dispatched. The handler for this event accepts two parameters. The first is either the result of a previous call to `mlhs_add` or the result of the [mlhs_new](#mlhs_new) event handler. The second parameter is the variable that is being assigned, which can be one of:

* [aref_field](#aref_field) if assigning into an enumerable (`collection[index]`)
* [field](#field) if assigning to a field on an object (`object.field`)
* [mlhs_paren](#mlhs_paren) if assigning into a destructured object with parentheses (`(first, second)`)
* [var_field](#var_field) if assigning to a local variable (`variable`)

```ruby
def on_mlhs_add(mlhs, part); end
```

### `mlhs_new`

`mlhs_new` is a parser event that represents the beginning of the left side of a multiple assignment. It is followed by any number of [mlhs_add](#mlhs_add) nodes that each represent another variable being assigned.

```ruby
first, second, third = value
```

In the above example, the `mlhs_new` event would be dispatched just before the `first` variable is declared. The handler for this event accepts no parameters as it is effectively the start of a list.

```ruby
def on_mlhs_new; end
```

### `mlhs_add_post`

`mlhs_add_post` is a parser event that represents adding another set of variables onto a list of assignments after a splat variable within a multiple assignment.

```ruby
left, *middle, right = values
```

In the example above, an `mlhs_add_post` event would be dispatched when the parser encountered the `right` token. The handler for this event accepts two parameters. The first is the [mlhs_add_star](#mlhs_add_star) the contains everything leading up to the splatted variable. The second is the [mlhs_add](#mlhs_add) that represents every variable after that splatted variable.

```ruby
def on_mlhs_add_post(mlhs_add_star, mlhs_add); end
```

### `mlhs_add_star`

`mlhs_add_star` is a parser event that represents a splatted variable inside of a multiple assignment on the left hand side.

```ruby
first, *rest = values
```

The handler for this event accepts two parameters. The first is the result of the first call to either [mlhs_new](#mlhs_new) (if the splatted variable is the first in the list) or [mlhs_add](#mlhs_add) (if the splatted variable is not the first in the list). The second is the node that represents the value being splatted, which can be many different nodes (usually a field node, but it depends on the expression type).

```ruby
def on_mlhs_add_star(mlhs, part); end
```

### `mlhs_paren`

`mlhs_paren` is a parser event that represents parentheses being used to destruct values in a multiple assignment on the left hand side.

```ruby
(left, right) = value
```

The handler for this event accepts one parameter which represents the value contained within the parentheses. Depending on the declaration, it can be an [mlhs_add](#mlhs_add), [mlhs_add_post](#mlhs_add_post), [mlhs_add_star](#mlhs_add_star), or a nested `mlhs_paren`.

```ruby
def on_mlhs_paren(contents); end
```

### `module`

`module` is a parser event that represents defining a module using the `module` keyword.

```ruby
module Namespace
end
```

The handler for this event accepts one parameter for the name of the module (a [const](#const) node) and one parameter for the statements inside the module (a [bodystmt](#bodystmt) node).

```ruby
def on_module(const, bodystmt); end
```

### `mrhs_add`

`mrhs_add` is a parser event that represents adding another value onto a list on the right hand side of a multiple assignment.

```ruby
values = first, second, third
```

In the example above, three `mrhs_add` events would be dispatched, one for each identifier in the list. The handler for this event accepts the result of the handler for [mrhs_new](#mrhs_new) (if it's the first element in the list) or `mrhs_add` if it's not, as well as the part that is being added which can be any Ruby expression.

```ruby
def on_mrhs_add(mrhs, part); end
```

### `mrhs_new`

`mrhs_new` is a parser event that represents the beginning of a list of values that are being assigned within a multiple assignment node. It can be followed by any number of [mrhs_add](#mrhs_add) nodes.

```ruby
values = first, second, third
```

In the example above, an `mrhs_new` event would be dispatched when the parser hits the `first` identifier. The handler for this event accepts no parameters as it represents the beginning of a list.

```ruby
def on_mrhs_new; end
```

### `mrhs_add_star`

`mrhs_add_star` is a parser event that represents using the splat operator to expand out a value on the right hand side of a multiple assignment.

```ruby
values = first, *rest
```

The handler for this event accepts two parameters. The first is either an [mrhs_new](#mrhs_new) (in the case that the splat is the only value being assigned) or an [mrhs_new_from_args](#mrhs_new_from_args) (in the case that multiple values are being assigned, as in the example above). The second is the part that is being splatted into the list, which can be any Ruby expression.

```ruby
def on_mrhs_add_star(mrhs, part); end
```

### `mrhs_new_from_args`

`mrhs_new_from_args` is a parser event that represents the shorthand of a multiple assignment that allows you to assign values using just commas as opposed to assigning from an array. For example, in the following segment the right hand side of the assignment would dispatch this event:

```ruby
values = first, second, third
```

The handler for this event accepts a single [args_add](#args_add) or [args_add_star](#args_add_star) node that represents the values being assigned.

```ruby
def on_mrhs_new_from_args(args); end
```

### `next`

`next` is a parser event that represents using the `next` keyword.

```ruby
next
```

The `next` keyword can also optionally be called with an argument:

```ruby
next value
```

`next` can even be called with multiple arguments, but only if parentheses are omitted, as in:

```ruby
next first, second, third
```

If a single value is being given, parentheses can be used, as in:

```ruby
next(value)
```

The handler for this event accepts a single parameter that represents the type of values being passed to the `next` keyword. In the case that no arguments are given, it's an [args_new](#args_new) node. If one or more arguments are given, it's an [args_add_block](#args_add_block) node.

```ruby
def on_next(args); end
```

### `nl`

`nl` is a scanner event representing a newline in the source. As you can imagine, it gets dispatched quite often, so take care if you're defining this method manually. 

The handler for this event accepts a single string parameter that always contains the value of the newline.

```ruby
def on_nl(value); end
```

### `nokw_param`

`nokw_param` is a parser event that represents the use of the Ruby 2.7+ syntax to indicate a method should take no additional keyword arguments. For example in the following snippet:

```ruby
def method(**nil) end
```

This example is saying that the method `method` should not accept any keyword arguments. The handler for this event accepts a single parameter that is always the value `nil`.

```ruby
def on_nokw_param(value); end
```

The result of this event handler will get passed up to the event handler for the [params](#params) node that it is a part of in the `kwrest` position.

### `op`

`op` is a scanner event representing an operator literal in the source. For example, in the following snippet:

```ruby
1 + 2
```

In the example above, the `+` operator would dispatch this event. The handler for this event accepts a single string parameter that represents the operator as seen in the source.

```ruby
def on_op(value); end
```

### `opassign`

`opassign` is a parser event that represents assigning a value to a variable or constant using an operator like `+=` or `||=`.

```ruby
variable += value
```

The handler for this event accepts three parameters. The first is the left side of the operator, which can be any kind of field node. The second is the [op](#op) node that represents the operator being used. The third is the right side of the operator, which can be any Ruby expression.

```ruby
def on_opassign(left, operator, right); end
```

### `operator_ambiguous`

`operator_ambiguous` is a parser event that represents when the parser sees an operator as ambiguous. For example, in the following snippet:

```ruby
method %[]
```

the question becomes if the percent sign is being used as a method call or if it's the start of a string literal. The handler for this event accepts two parameters. The first is a symbol that represents the operator that dispatched this event (in the case of this example it would be `:%`). The second is a string that is used to indicate the kind of ambiguity (these are defined explicitly in the parser, in the case of this example it would be `"string literal"`).

```ruby
def on_operator_ambiguous(operator, ambiguity); end
```

### `params`

`params` is a parser event that represents defining parameters on a method or lambda.

```ruby
def method(param) end
```

In the example above a `params` event would be dispatched when the parser found the `param` identifier. The handler for this event accepts seven parameters, each indicating the presence of a different type of parameter (so they can all be `nil`). They are, in order:

* Positional parameters (`req`) - an array of [ident](#ident) nodes
* Optional parameters (`opt`) - an array of pairs containing [ident](#ident) nodes for the name as well as a node representing whatever expression is being used for the default value
* Rest parameter (`rest`) - either an [args_forward](#args_forward) node (if argument forwarding is being used), an [excessed_comma](#excessed_comma) node (if a trailing comma is present to indicate destructuring), or a [rest_param](#rest_param) node to represent a splat
* Post parameters (`req`) - an array of [ident](#ident) nodes that represent the list of parameters occuring _after_ a rest parameter
* Keyword parameters (`keyreq` and `key`) - an array of pairs containing [label](#label) nodes for the name as well as a node representing whatever expresion is used for the default value (or `false` if none is provided)
* Keyword rest parameter (`keyrest` or `nokey`) - either a [kwrest_param](#kwrest_param) node if a double-splat operator is being used to gather up remaining keyword arguments or the symbol `:nil` if it's using the `**nil` syntax
* Block parameter (`block`) - a [blockarg](#blockarg) node

Note that the shorthands above come from calling the `Method#parameters` method.

```ruby
def on_params(req, opts, rest, post, keys, keyrest, block); end
```

### `paren`

`paren` is a parser event that represents using balanced parentheses in a couple places in a Ruby program. In general parentheses can be used anywhere a Ruby expression can be used.

```ruby
(1 + 2)
```

The handler for this event accepts a single parameter that represents the expression inside the parentheses.

```ruby
def on_paren(contents); end
```

### `period`

`period` is a scanner event that represents the use of the `.` operator. It is usually found in method calls.

The handler for this event accepts a single string parameter that always contains the value `"."`.

```ruby
def on_period(value); end
```

### `program`

`program` is a parser event that represents the overall syntax tree. It will always be called when a Ripper parser is used.

The handler for this event accepts a single [stmts_add](#stmts_add) node that represents the top-level statements of the source.

```ruby
def on_program(stmts_add); end
```

### `qsymbols_beg`

`qsymbols_beg` is a scanner event that represents the beginning of a symbol literal array. For example:

```ruby
%i[one two three]
```

In the snippet above, a `qsymbols_beg` event would be dispatched with the value of `"%i["`. The handler for this event accepts a single string parameter representing the token as seen in the source. Note that these kinds of arrays can start with a lot of different delimiter types (e.g., `%i|` or `%i<`).

```ruby
def on_qsymbols_beg(value); end
```

### `qsymbols_add`

`qsymbols_add` is a parser event that represents adding an element to a symbol literal array.

```ruby
%i[one two three]
```

In the example above, three `qsymbols_add` events would be dispatched. The first would be with the result of the [qsymbols_new](#qsymbols_new) event handler, the second with the result of the first `qsymbols_add` event handler call, and the third with the result of the second call.

The handler for this event accepts the current list of symbols (as a [qsymbols_new](#qsymbols_new) or [qsymbols_add](#qsymbols_add) node) and the next value that should be added (always a [tstring_content](#tstring_content) node).

```ruby
def on_qsymbols_add(qsymbols, tstring_content); end
```

### `qsymbols_new`

`qsymbols_new` is a parser event that represents the beginning of a symbol literal array.

```ruby
%i[one two three]
```

In the axample above, a `qsymbols_new` event would be dispatched when the parser finds the `one` token. It can be followed by any number of [qsymbols_add](#qsymbols_add) events. The handler for this event accepts no parameters, as it's the start of a list.

```ruby
def on_qsymbols_new; end
```

### `qwords_beg`

`qwords_beg` is a scanner event that represents the beginning of a string literal array. For example:

```ruby
%w[one two three]
```

In the snippet above, a `qwords_beg` event would be dispatched with the value of `"%w["`. The handler for this event accepts a single string parameter representing the token as seen in the source. Note that these kinds of arrays can start with a lot of different delimiter types (e.g., `%w|` or `%w<`).

```ruby
def on_qwords_beg(value); end
```

### `qwords_add`

`qwords_add` is a parser event that represents adding an element to a string literal array.

```ruby
%w[one two three]
```

In the example above, three `qwords_add` events would be dispatched. The first would be with the result of the [qwords_new](#qwords_new) event handler, the second with the result of the first `qwords_add` event handler call, and the third with the result of the second call.

The handler for this event accepts the current list of strings (as a [qwords_new](#qwords_new) or [qwords_add](#qwords_add) node) and the next value that should be added (always a [tstring_content](#tstring_content) node).

```ruby
def on_qwords_add(qwords, tstring_content); end
```

### `qwords_new`

`qwords_new` is a parser event that represents the beginning of a string literal array.

```ruby
%w[one two three]
```

In the axample above, a `qwords_new` event would be dispatched when the parser finds the `one` token. It can be followed by any number of [qwords_add](#qwords_add) events. The handler for this event accepts no parameters, as it's the start of a list.

```ruby
def on_qwords_new; end
```

### `rational`

`rational` is a scanner event that represents the use of a rational number literal.

```ruby
1r
```

The handler for this event accepts a single string parameter representing the value as seen in source.

```ruby
def on_rational(value); end
```

### `rbrace`

`rbrace` is a scanner event that represents the use of a right brace, i.e., `}`.

The handler for this event accepts a single string parameter that always contains the value `"}"`.

```ruby
def on_rbrace(value); end
```

### `rbracket`

`rbracket` is a scanner event that represents the use of a right bracket, i.e., `]`.

The handler for this event accepts a single string parameter that always contains the value `"]"`.

```ruby
def on_rbracket(value); end
```

### `redo`

`redo` is a parser event that represents the use of the `redo` keyword.

```ruby
redo
```

The handler for this event accepts no parameters as the `redo` keyword accepts no arguments.

```ruby
def on_redo; end
```

### `regexp_add`

`regexp_add` is a parser event that represents a piece of a regular expression body.

```ruby
/.+ #{pattern} .+/
```

In the example above, three `regexp_add` events would be dispatched. The first would be for the [tstring_content](#tstring_content) node representing everything up to the interpolation. The second would be for the interpolated expression. The final would be for the second [tstring_content](#tstring_content) node representing everything after the interpolation.

The handler for this event accepts two parameters. The first is the result of the call to the previous `regexp_add` (if this is not the first part of the regular expression) or the result of the call to [regexp_new](#regexp_new) (if this is the first part of the regular expression). The second is the piece that is being added to the list of parts, which can be a [tstring_content](#tstring_content) for plain string content, a [string_embexpr](#string_embexpr) for an interpolated expression, or a [string_dvar](#string_dvar) for the shorthand variable interpolation.

```ruby
def on_regexp_add(regexp, part); end
```

### `regexp_beg`

`regexp_beg` is a scanner event that represents the start of a regular expression literal.

```ruby
/.+/
```

In the example above, the `regexp_beg` event would be dispatched when the parser sees the `/` token. Regular expression literals can also be declared using the `%r` syntax, as in:

```ruby
%r{.+}
```

The handler for this event accepts a single string parameter that represents the start of the regular expression literal (either the `"/"` or the `"%r{"` in the examples above).

```ruby
def on_regexp_beg(value); end
```

### `regexp_end`

`regexp_end` is a scanner event that represents the end of a regular expression literal.

```ruby
/.+/m
```

In the example above, the `regexp_end` event represents the `/m` at the end of the regular expression literal. You can also declare regular expression literals using `%r`, as in:

```ruby
%r{.+}m
```

The handler for this event accepts a single string parameter that represents the end of the regular expression literal (either the `"/m"` or the `"}m"` in the examples above).

```ruby
def on_regexp_end(value); end
```

### `regexp_literal`

`regexp_literal` is a parser event that represents a regular expression literal.

```ruby
/.+/
```

The handler for this event accepts two parameters. The first is either a [regexp_new](#regexp_new) node (if the regular expression literal is empty) or [regexp_add](#regexp_add) (if there is content in the regular expression literal). The second is a [regexp_end](#regexp_end) node that represents the end of the declaration of the regular expression literal.

```ruby
def on_regexp_literal(regexp, ending); end
```

### `regexp_new`

`regexp_new` is a parser event that represents the beginning of a regular expression literal.

```ruby
/.+/
```

In the example above, a `regexp_new` event would be dispatched just before the `.+` [tstring_content](#tstring_content) node. The handler for this event accepts no parameters as it's the start of a list.

```ruby
def on_regexp_new; end
```

### `rescue`

`rescue` is a parser event that represents the use of the `rescue` keyword inside of a [bodystmt](#bodystmt) node.

```ruby
begin
rescue
end
```

You can optionally rescue a list of exceptions (either in the form of constants by referencing them directly or in the form of variables that reference exceptions), as in:

```ruby
begin
rescue exception
rescue IOError, SyntaxError
end
```

You can also assign the rescued error to a variable, as in:

```ruby
begin
rescue => error
end
```

Finally, you can rescue a specific error and then assign it to a variable, as in:

```ruby
begin
rescue IOError => error
end
```

The handler for this event accepts four parameters. The first is the list of exceptions that are being rescued. This is either `nil` (if there are no explicit exceptions being rescued), an array containing a single node (if only one exception is being rescued), a [mrhs_add](#mrhs_add) node (if multiple exceptions are being rescued), or an [mrhs_add_star](#mrhs_add_star) node (if multiple exceptions are being rescued and its using a splat). The second is an optional variable being used to capture the exception. The third is a [stmts_add](#stmts_add) node representing the statements inside the `rescue` clause. Finally, the fourth is an optional consequent `rescue` clause if one is present.

```ruby
def on_rescue(exceptions, variable, stmts_add, consequent); end
```

### `rescue_mod`

`rescue_mod` is a parser event that represents the using modifier form of a `rescue` clause.

```ruby
expression rescue value
```

The handler for this event accepts one parameter for the statement that is being rescued and one parameter for the value that should be used if an exception is raised. Both can be any Ruby expression.

```ruby
def on_rescue_mod(statement, rescued); end
```

### `rest_param`

`rest_param` is a parser event that represents defining a parameter in a method definition that accepts all remaining positional parameters.

```ruby
def method(*rest) end
```

The handler for this event accepts a single optional [ident](#ident) parameter that represents the name assigned to the rest parameter. If no name is provided (just a bare `*`), then this parameter will be `nil`.

```ruby
def on_rest_param(ident); end
```

### `retry`

`retry` is a parser event that represents the use of the `retry` keyword.

```ruby
retry
```

The handler for this event accepts no parameters as the `retry` keyword accepts no arguments.

```ruby
def on_retry; end
```

### `return`

`return` is a parser event that represents using the return keyword with arguments.

```ruby
return value
```

The handler for this event accepts a single [args_add_block](#args_add_block) event that contains all of the arguments being passed to the keyword.

```ruby
def on_return(args_add_block); end
```

### `return0`

`return0` is a parser event that represents the bare return keyword.

```ruby
return
```

The handler for this event accepts no parameters.

```ruby
def on_return0; end
```

### `rparen`

`rparen` is a scanner event that represents the use of a right parenthesis, i.e., `)`.

The handler for this event accepts a single string parameter that always contains the value `")"`.

```ruby
def on_rparen(value); end
```

### `sclass`

`sclass` is a parser event that represents a block of statements that should be evaluated within the context of the singleton class of an object. It's frequently used to define singleton methods. It looks like the following example:

```ruby
class << self
end
```

The handler for this event accepts two parameters. The first is the object whose singleton class the statements should be evaluated in. In the example above it would be the [var_ref](#var_ref) representing the `self` keyword. The second is the [bodystmt](#bodystmt) node that represents the statements inside the block.

```ruby
def on_sclass(object, bodystmt); end
```

### `semicolon`

`semicolon` is a scanner event that represents the use of a semicolon in the source.

```ruby
;
```

The handler for this event accepts a single string parameter that always contains the value `";"`.

```ruby
def on_semicolon(value); end
```

### `sp`

`sp` is a scanner event that represents the use of a space in the source. As you can imagine, this event gets triggered quite often, so take care when manually defining the event handler for this event.

The handler for this event accepts a single string parameter that always contains the value `" "`.

```ruby
def on_sp(value); end
```

### `stmts_add`

`stmts_add` is a parser event that represents a single statement inside a list of statements within any lexical block.

The handler for this event accepts two parameters. The first is the accumulated list of statements (either a [stmts_new](#stmts_new) if it's the first statement or a `stmts_add` if it's not the first statement). The second is the statement that we're adding to the list which can be any Ruby expression.

```ruby
def on_stmts_add(stmts, stmt); end
```

### `stmts_new`

`stmts_new` is a parser event that represents the beginning of a list of statements within any lexical block. It can be followed by any number of `stmts_add` events.

The handler for this event accepts no parameters as it's the start of a list.

```ruby
def on_stmts_new; end
```

### `string_add`

`string_add` is a parser event that represents adding a section onto a string.

```ruby
"left #{middle} right"
```

In the example above, three `string_add` events would be dispatched. The first would be for the [tstring_content](#tstring_content) on the left side of the interpolation. The second would be for the [string_embexpr](#string_embexpr) representing the interpolation. The third would be for the [tstring_content](#tstring_content) on the right side of the interpolation.

The handler for this event accepts two parameters. The first is a [string_content](#string_content) if it's the first part of the string or a `string_add` if it's not the first part. The second is the part that is being added to the string, which can be a [tstring_content](#tstring_content) for plain string content, a [string_embexpr](#string_embexpr) for an interpolated expression, or a [string_dvar](#string_dvar) for a shorthand variable interpolation.

```ruby
def on_string_add(string, part); end
```

### `string_concat`

`string_concat` is a parser event that represents concatenating two strings together using a backward slash, as in the following example:

```ruby
"first" \
  "second"
```

The handler for this event accepts two parameters. The first is either a `string_concat` or a [string_literal](#string_literal). The second is always the trailing [string_literal](#string_literal).

```ruby
def on_string_concat(left, right); end
```

### `string_content`

`string_content` is a parser event that represents the beginning of the contents of a string.

```ruby
"string"
```

In the example above, a `string_content` event would be dispatched when the parser encounters the `string` token. The handler for this event accepts no parameters as its the beginning of a list.

```ruby
def on_string_content; end
```

### `string_dvar`

`string_dvar` is a parser event that represents shorthand interpolation of a variable into a string. It allows you to take an instance variable, class variable, or global variable and omit the braces when interpolating. For example, if you wanted to interpolate the instance variable `@variable` into a string, you would write:

```ruby
"#@variable"
```

The handler for this event accepts a single parameter that represents the variable being interpolated. This can either be a [var_ref](#var_ref) or a [backref](#backref).

```ruby
def on_string_dvar(variable); end
```

### `string_embexpr`

`string_embexpr` is a parser event that represents interpolated content. It can be contained within a couple of different parent nodes, including regular expressions, strings, and dynamic symbols.

```ruby
"string #{expression}"
```

The handler for this event accepts a single [stmts_add](#stmts_add) node representing the statements contained within the interpolation.

```ruby
def on_string_embexpr(stmts_add); end
```

### `string_literal`

`string_literal` is a parser event that represents a string literal.

```ruby
"string"
```

It is also used to represent a heredoc literal.

```ruby
<<~DOC
  string
DOC
```

The handler for this event accepts a single [string_content](#string_content) node (if the string is empty) or a [string_add](#string_add) node (if the string is not empty).

```ruby
def on_string_literal(string); end
```

<!--
export type Super = ParserEvent<"super", { body: [Args | ArgParen | ArgsAddBlock] }>;
export type SymbolLiteral = ParserEvent<"symbol_literal", { body: [Backtick | Const | CVar | GVar | Identifier | IVar | Keyword | Op] }>;
export type Symbols = ParserEvent<"symbols", { body: Word[] }>;
export type Ternary = ParserEvent<"ifop", { body: [AnyNode, AnyNode, AnyNode] }>;
export type TopConstField = ParserEvent<"top_const_field", { body: [Const] }>;
export type TopConstRef = ParserEvent<"top_const_ref", { body: [Const] }>;
export type Unary = ParserEvent<"unary", { body: [AnyNode], oper: string, paren: boolean | undefined }>;
export type Undef = ParserEvent<"undef", { body: (DynaSymbol | SymbolLiteral)[] }>;
export type Unless = ParserEvent<"unless", { body: [AnyNode, Stmts, null | Elsif | Else] }>;
export type UnlessModifier = ParserEvent<"unless_mod", { body: [AnyNode, AnyNode] }>;
export type Until = ParserEvent<"until", { body: [AnyNode, Stmts] }>;
export type UntilModifier = ParserEvent<"until_mod", { body: [AnyNode, AnyNode] }>;
export type VCall = ParserEvent<"vcall", { body: [Identifier] }>;
export type VarAlias = ParserEvent<"var_alias", { body: [GVar, Backref | GVar] }>;
export type VarField = ParserEvent<"var_field", { body: [null | Const | CVar | GVar | Identifier | IVar] }>;
export type VarRef = ParserEvent<"var_ref", { body: [Const | CVar | GVar | Identifier | IVar | Keyword] }>;
export type VoidStmt = ParserEvent<"void_stmt">;
export type When = ParserEvent<"when", { body: [Args | ArgsAddStar, Stmts, null | Else | When] }>;
export type While = ParserEvent<"while", { body: [AnyNode, Stmts] }>;
export type WhileModifier = ParserEvent<"while_mod", { body: [AnyNode, AnyNode] }>;
export type Word = ParserEvent<"word", { body: StringContent[] }>;
export type Words = ParserEvent<"words", { body: Word[] }>;
export type XStringLiteral = ParserEvent<"xstring_literal", { body: StringContent[] }>;
export type Yield = ParserEvent<"yield", { body: [ArgsAddBlock | Paren] }>;
export type Yield0 = ParserEvent0<"yield0">;
export type Zsuper = ParserEvent0<"zsuper">;

# A super is a parser event that represents using the super keyword with
# any number of arguments. It can optionally use parentheses (represented
# by an arg_paren node) or just skip straight to the arguments (with an
# args_add_block node).
def on_super(contents)
  find_scanner_event(:@kw, 'super').merge!(
    type: :super,
    body: [contents],
    el: contents[:el],
    ec: contents[:ec]
  )
end

# symbeg is a scanner event that represents the beginning of a symbol literal.
# In most cases it will contain just ":" as in the value, but if its a dynamic
# symbol being defined it will contain ":'" or ":\"".
def on_symbeg(value)
  start_line = lineno
  start_char = char_pos

  node = {
    type: :@symbeg,
    body: value,
    sl: start_line,
    el: start_line,
    sc: start_char,
    ec: start_char + value.size
  }

  scanner_events << node
  node
end

# A symbol is a parser event that immediately descends from a symbol
# literal and contains an ident representing the contents of the symbol.
def on_symbol(ident)
  # When ripper is lexing source text, it turns symbols into keywords if their
  # contents match, which will mess up the location information of all of our
  # other nodes. So for example instead of { type: :@ident, body: "class" }
  # you would instead get { type: :@kw, body: "class" }.
  #
  # In order to take care of this, we explicitly delete this scanner event
  # from the stack to make sure it doesn't screw things up.
  scanner_events.pop

  ident.merge(type: :symbol, body: [ident])
end

# A symbol_literal represents a symbol in the system with no interpolation
# (as opposed to a dyna_symbol). As its only argument it accepts either a
# symbol node (for most cases) or an ident node (in the case that we're
# using bare words, as in an alias node like alias foo bar).
def on_symbol_literal(contents)
  if scanner_events[-1] == contents
    contents.merge(type: :symbol_literal, body: [contents])
  else
    beging = find_scanner_event(:@symbeg)
    contents.merge!(type: :symbol_literal, sc: beging[:sc])
  end
end

# symbols_beg is a scanner event that represents the start of a symbol literal
# array with interpolation. For example, in the following snippet:
#
#     %I[foo bar baz]
#
# symbols_beg would be triggered with the value of "%I".
def on_symbols_beg(value)
  start_line = lineno
  start_char = char_pos

  node = {
    type: :@symbols_beg,
    body: value,
    sl: start_line,
    el: start_line,
    sc: start_char,
    ec: start_char + value.size
  }

  scanner_events << node
  node
end

# symbols_new is a parser event that represents the beginning of a symbol
# literal array that accepts interpolation, like %I[one #{two} three]. It
# can be followed by any number of symbols_add events, which we'll append
# onto an array body.
def on_symbols_new
  find_scanner_event(:@symbols_beg).merge!(type: :symbols, body: [])
end

# symbols_add is a parser event that represents an element inside of a
# symbol literal array that accepts interpolation, like
# %I[one #{two} three]. It accepts as arguments the parent symbols node as
# well as a word_add parser event.
def on_symbols_add(symbols, word_add)
  symbols.merge!(
    body: symbols[:body] << word_add,
    el: word_add[:el],
    ec: word_add[:ec]
  )
end

# tlambda is a scanner event that represents the beginning of a lambda
# literal. It always has the value of "->".
def on_tlambda(value)
  start_line = lineno
  start_char = char_pos

  node = {
    type: :@tlambda,
    body: value,
    sl: start_line,
    el: start_line,
    sc: start_char,
    ec: start_char + value.size
  }

  scanner_events << node
  node
end

# tlambeg is a scanner event that represents the beginning of the body of a
# lambda literal. It always has the value of "{".
def on_tlambeg(value)
  start_line = lineno
  start_char = char_pos

  node = {
    type: :@tlambeg,
    body: value,
    sl: start_line,
    el: start_line,
    sc: start_char,
    ec: start_char + value.size
  }

  scanner_events << node
  node
end

# A top_const_field is a parser event that is always the child of some
# kind of assignment. It represents when you're assigning to a constant
# that is being referenced at the top level. For example:
#
#     ::X = 1
#
def on_top_const_field(const)
  beging = find_colon2_before(const)
  const.merge(
    type: :top_const_field,
    body: [const],
    sl: beging[:sl],
    sc: beging[:sc]
  )
end

# A top_const_ref is a parser event that is a very similar to
# top_const_field except that it is not involved in an assignment. It
# looks like the following example:
#
#     ::X
#
def on_top_const_ref(const)
  beging = find_colon2_before(const)
  const.merge(
    type: :top_const_ref,
    body: [const],
    sl: beging[:sl],
    sc: beging[:sc]
  )
end

# tstring_beg is a scanner event that represents the beginning of a string
# literal. It can represent either of the quotes for its value, or it can have
# a %q/%Q with delimiter.
def on_tstring_beg(value)
  start_line = lineno
  start_char = char_pos

  node = {
    type: :@tstring_beg,
    body: value,
    sl: start_line,
    el: start_line,
    sc: start_char,
    ec: start_char + value.size
  }

  scanner_events << node
  node
end

# tstring_content is a scanner event that represents plain characters inside
# of a string, heredoc, xstring, or regexp. Like comments, we need to force
# the encoding here so JSON doesn't break.
def on_tstring_content(value)
  start_line = lineno
  start_char = char_pos

  {
    type: :@tstring_content,
    body: value.force_encoding('UTF-8'),
    sl: start_line,
    el: start_line,
    sc: start_char,
    ec: start_char + value.size
  }
end

# tstring_end is a scanner event that represents the end of a string literal.
# It can either contain quotes, or it can have the end delimiter of a %q/%Q
# literal.
def on_tstring_end(value)
  start_line = lineno
  start_char = char_pos

  node = {
    type: :@tstring_end,
    body: value,
    sl: start_line,
    el: start_line,
    sc: start_char,
    ec: start_char + value.size
  }

  scanner_events << node
  node
end

# A unary node represents a unary method being called on an expression, as
# in !, ~, or not. We have somewhat special handling of the not operator
# since if it has parentheses they don't get reported as a paren node for
# some reason.
def on_unary(oper, value)
  if oper == :not
    node = find_scanner_event(:@kw, 'not')

    paren = source[node[:ec]...value[:sc]].include?('(')
    ending = paren ? find_scanner_event(:@rparen) : value

    node.merge!(
      type: :unary,
      oper: oper,
      body: [value],
      el: ending[:el],
      ec: ending[:ec],
      paren: paren
    )
  else
    # Special case instead of using find_scanner_event here. It turns out that
    # if you have a range that goes from a negative number to a negative
    # number then you can end up with a .. or a ... that's higher in the
    # stack. So we need to explicitly disallow those operators.
    index =
      scanner_events.rindex do |scanner_event|
        scanner_event[:type] == :@op && scanner_event[:sc] < value[:sc] &&
          !%w[.. ...].include?(scanner_event[:body])
      end

    beging = scanner_events.delete_at(index)
    beging.merge!(
      type: :unary,
      oper: oper[0],
      body: [value],
      el: value[:el],
      ec: value[:ec]
    )
  end
end

# undef nodes represent using the keyword undef. It accepts as an argument
# an array of symbol_literal nodes that represent each message that the
# user is attempting to undefine. We use the keyword to get the beginning
# location and the last symbol to get the ending.
def on_undef(symbol_literals)
  last = symbol_literals.last

  find_scanner_event(:@kw, 'undef').merge!(
    type: :undef,
    body: symbol_literals,
    el: last[:el],
    ec: last[:ec]
  )
end

# unless is a parser event that represents the first clause in an unless
# chain. It accepts as arguments the predicate of the unless, the
# statements that are contained within the unless clause, and the optional
# consequent clause.
def on_unless(predicate, stmts, consequent)
  beging = find_scanner_event(:@kw, 'unless')
  ending = consequent || find_scanner_event(:@kw, 'end')

  stmts.bind(predicate[:ec], ending[:sc])

  {
    type: :unless,
    body: [predicate, stmts, consequent],
    sl: beging[:sl],
    sc: beging[:sc],
    el: ending[:el],
    ec: ending[:ec]
  }
end

# unless_mod is a parser event that represents the modifier form of an
# unless statement. It accepts as arguments the predicate of the unless
# and the statement that are contained within the unless clause.
def on_unless_mod(predicate, statement)
  find_scanner_event(:@kw, 'unless')

  {
    type: :unless_mod,
    body: [predicate, statement],
    sl: statement[:sl],
    sc: statement[:sc],
    el: predicate[:el],
    ec: predicate[:ec]
  }
end

# until is a parser event that represents an until loop. It accepts as
# arguments the predicate to the until and the statements that are
# contained within the until clause.
def on_until(predicate, stmts)
  beging = find_scanner_event(:@kw, 'until')
  ending = find_scanner_event(:@kw, 'end')

  # Consume the do keyword if it exists so that it doesn't get confused for
  # some other block
  do_event = find_scanner_event(:@kw, 'do', consume: false)
  if do_event && do_event[:sc] > predicate[:ec] && do_event[:ec] < ending[:sc]
    scanner_events.delete(do_event)
  end

  stmts.bind(predicate[:ec], ending[:sc])

  {
    type: :until,
    body: [predicate, stmts],
    sl: beging[:sl],
    sc: beging[:sc],
    el: ending[:el],
    ec: ending[:ec]
  }
end

# until_mod is a parser event that represents the modifier form of an
# until loop. It accepts as arguments the predicate to the until and the
# statement that is contained within the until loop.
def on_until_mod(predicate, statement)
  find_scanner_event(:@kw, 'until')

  {
    type: :until_mod,
    body: [predicate, statement],
    sl: statement[:sl],
    sc: statement[:sc],
    el: predicate[:el],
    ec: predicate[:ec]
  }
end

# var_alias is a parser event that represents when you're using the alias
# keyword with global variable arguments. You can optionally use
# parentheses with this keyword, so we either track the location
# information based on those or the final argument to the alias method.
def on_var_alias(left, right)
  beging = find_scanner_event(:@kw, 'alias')

  paren = source[beging[:ec]...left[:sc]].include?('(')
  ending = paren ? find_scanner_event(:@rparen) : right

  {
    type: :var_alias,
    body: [left, right],
    sl: beging[:sl],
    sc: beging[:sc],
    el: ending[:el],
    ec: ending[:ec]
  }
end

# var_ref is a parser event that represents using either a local variable,
# a nil literal, a true or false literal, or a numbered block variable.
def on_var_ref(contents)
  contents.merge(type: :var_ref, body: [contents])
end

# var_field is a parser event that represents a variable that is being
# assigned a value. As such, it is always a child of an assignment type
# node. For example, in the following example foo is a var_field:
#
#     foo = 1
#
def on_var_field(ident)
  if ident
    ident.merge(type: :var_field, body: [ident])
  else
    # You can hit this pattern if you're assigning to a splat using pattern
    # matching syntax in Ruby 2.7+
    { type: :var_field, body: nil }
  end
end

# vcall nodes are any plain named thing with Ruby that could be either a
# local variable or a method call. They accept as an argument the ident
# scanner event that contains their content.
#
# Access controls like private, protected, and public are reported as
# vcall nodes since they're technically method calls. We want to be able
# add new lines around them as necessary, so here we're going to
# explicitly track those as a different node type.
def on_vcall(ident)
  @controls ||= %w[private protected public].freeze

  body = ident[:body]
  type =
    if @controls.include?(body) && body == lines[lineno - 1].strip
      :access_ctrl
    else
      :vcall
    end

  ident.merge(type: type, body: [ident])
end

# void_stmt is a special kind of parser event that represents an empty lexical
# block of code. It often will have comments attached to it, so it requires
# some special handling.
def on_void_stmt
  { type: :void_stmt, sl: lineno, el: lineno, sc: char_pos, ec: char_pos }
end

# when is a parser event that represents another clause in a case chain.
# It accepts as arguments the predicate of the when, the statements that
# are contained within the else if clause, and the optional consequent
# clause.
def on_when(predicate, stmts, consequent)
  beging = find_scanner_event(:@kw, 'when')
  ending = consequent || find_scanner_event(:@kw, 'end')

  stmts.bind(predicate[:ec], ending[:sc])

  {
    type: :when,
    body: [predicate, stmts, consequent],
    sl: beging[:sl],
    sc: beging[:sc],
    el: ending[:el],
    ec: ending[:ec]
  }
end

# while is a parser event that represents a while loop. It accepts as
# arguments the predicate to the while and the statements that are
# contained within the while clause.
def on_while(predicate, stmts)
  beging = find_scanner_event(:@kw, 'while')
  ending = find_scanner_event(:@kw, 'end')

  # Consume the do keyword if it exists so that it doesn't get confused for
  # some other block
  do_event = find_scanner_event(:@kw, 'do', consume: false)
  if do_event && do_event[:sc] > predicate[:ec] && do_event[:ec] < ending[:sc]
    scanner_events.delete(do_event)
  end

  stmts.bind(predicate[:ec], ending[:sc])

  {
    type: :while,
    body: [predicate, stmts],
    sl: beging[:sl],
    sc: beging[:sc],
    el: ending[:el],
    ec: ending[:ec]
  }
end

# while_mod is a parser event that represents the modifier form of an
# while loop. It accepts as arguments the predicate to the while and the
# statement that is contained within the while loop.
def on_while_mod(predicate, statement)
  find_scanner_event(:@kw, 'while')

  {
    type: :while_mod,
    body: [predicate, statement],
    sl: statement[:sl],
    sc: statement[:sc],
    el: predicate[:el],
    ec: predicate[:ec]
  }
end

# word_new is a parser event that represents the beginning of a word
# within a special array literal (either strings or symbols) that accepts
# interpolation. For example, in the following array, there are three
# word nodes:
#
#     %W[one a#{two}a three]
#
# Each word inside that array is represented as its own node, which is in
# terms of the parser a tree of word_new and word_add nodes. For our
# purposes, we're going to report this as a word node and build up an
# array body of our parts.
def on_word_new
  { type: :word, body: [] }
end

# word_add is a parser event that represents a piece of a word within a
# special array literal that accepts interpolation. It accepts as
# arguments the parent word node as well as the additional piece of the
# word, which can be either a @tstring_content node for a plain string
# piece or a string_embexpr for an interpolated piece.
def on_word_add(word, piece)
  if word[:body].empty?
    # Here we're making sure we get the correct bounds by using the
    # location information from the first piece.
    piece.merge(type: :word, body: [piece])
  else
    word.merge!(body: word[:body] << piece, el: piece[:el], ec: piece[:ec])
  end
end

# words_beg is a scanner event that represents the start of a word literal
# array with interpolation. For example, in the following snippet:
#
#     %W[foo bar baz]
#
# words_beg would be triggered with the value of "%W".
def on_words_beg(value)
  start_line = lineno
  start_char = char_pos

  node = {
    type: :@words_beg,
    body: value,
    sl: start_line,
    el: start_line,
    sc: start_char,
    ec: start_char + value.size
  }

  scanner_events << node
  node
end

# words_sep is a scanner event that represents the separate between two words
# inside of a word literal array. It contains any amount of whitespace
# characters that are used to delimit the words. For example,
#
#     %w[
#       foo
#       bar
#       baz
#     ]
#
# in the snippet above there would be two words_sep events triggered, one
# between foo and bar and one between bar and baz. We don't need to track this
# event in the AST that we're generating, so we're not going to define an
# explicit handler for it.
#
#     def on_words_sep(value)
#       value
#     end

# words_new is a parser event that represents the beginning of a string
# literal array that accepts interpolation, like %W[one #{two} three]. It
# can be followed by any number of words_add events, which we'll append
# onto an array body.
def on_words_new
  find_scanner_event(:@words_beg).merge!(type: :words, body: [])
end

# words_add is a parser event that represents an element inside of a
# string literal array that accepts interpolation, like
# %W[one #{two} three]. It accepts as arguments the parent words node as
# well as a word_add parser event.
def on_words_add(words, word_add)
  words.merge!(
    body: words[:body] << word_add,
    el: word_add[:el],
    ec: word_add[:ec]
  )
end

# xstring_new is a parser event that represents the beginning of a string
# of commands that gets sent out to the terminal, like `ls`. It can
# optionally include interpolation much like a regular string, so we're
# going to build up an array body.
#
# If the xstring actually starts with a heredoc declaration, then we're
# going to let heredocs continue to do their thing and instead just use
# its location information.
def on_xstring_new
  heredoc = @heredocs[-1]

  if heredoc && heredoc[:beging][3] = '`'
    heredoc.merge(type: :xstring, body: [])
  elsif RUBY_MAJOR <= 2 && RUBY_MINOR <= 5 && RUBY_PATCH < 7
    { type: :xstring, body: [] }
  else
    find_scanner_event(:@backtick).merge!(type: :xstring, body: [])
  end
end

# xstring_add is a parser event that represents a piece of a string of
# commands that gets sent out to the terminal, like `ls`. It accepts two
# arguments, the parent xstring node as well as the piece that is being
# added to the string. Because it supports interpolation this is either a
# tstring_content scanner event representing bare string content or a
# string_embexpr representing interpolated content.
def on_xstring_add(xstring, piece)
  xstring.merge!(
    body: xstring[:body] << piece,
    el: piece[:el],
    ec: piece[:ec]
  )
end

# xstring_literal is a parser event that represents a string of commands
# that gets sent to the terminal, like `ls`. It accepts as its only
# argument an xstring node that is a built up array representation of all
# of the parts of the string (including the plain string content and the
# interpolated content).
#
# They can also use heredocs to present themselves, as in the example:
#
#     <<-`SHELL`
#       ls
#     SHELL
#
# In this case we need to change the node type to be a heredoc instead of
# an xstring_literal in order to get the right formatting.
def on_xstring_literal(xstring)
  heredoc = @heredocs[-1]

  if heredoc && heredoc[:beging][3] = '`'
    heredoc.merge!(body: xstring[:body])
  else
    ending = find_scanner_event(:@tstring_end)
    xstring.merge!(type: :xstring_literal, el: ending[:el], ec: ending[:ec])
  end
end

# yield is a parser event that represents using the yield keyword with
# arguments. It accepts as an argument an args_add_block event that
# contains all of the arguments being passed.
def on_yield(args_add_block)
  find_scanner_event(:@kw, 'yield').merge!(
    type: :yield,
    body: [args_add_block],
    el: args_add_block[:el],
    ec: args_add_block[:ec]
  )
end

# yield0 is a parser event that represents the bare yield keyword. It has
# no body as it accepts no arguments. This is as opposed to the yield
# parser event, which is the version where you're yielding one or more
# values.
def on_yield0
  find_scanner_event(:@kw, 'yield').merge!(type: :yield0)
end

# zsuper is a parser event that represents the bare super keyword. It has
# no body as it accepts no arguments. This is as opposed to the super
# parser event, which is the version where you're calling super with one
# or more values.
def on_zsuper
  find_scanner_event(:@kw, 'super').merge!(type: :zsuper)
end

## Errors

# If we encounter a parse error, just immediately bail out so that our runner
# can catch it.
def on_parse_error(error, *)
  raise ParserError.new(error, lineno, column)
end
alias on_alias_error on_parse_error
alias on_assign_error on_parse_error
alias on_class_name_error on_parse_error
alias on_param_error on_parse_error
-->
